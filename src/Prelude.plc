(program

  ;;
  ;; Function Tools
  ;;
  
  (declare id (forall a (type) (fun a a)))
  (define id
    (abs a (lam x x)))
  
  
  (declare const
    (forall a (type) (forall b (type)
      (fun a (fun b a)))))
  (define const
    (abs a (abs b
      (lam x (lam y x)))))
  
  
  (declare flip
    (forall a (type) (forall b (type) (forall c (type)
      (fun (fun a (fun b c))
           (fun b (fun a c)))))))
  (define flip
    (abs a (abs b (abs c
      (lam f (lam x (lam y
        [f y x])))))))
  
  
  (declare applyTo
    (forall a (type) (forall b (type)
      (fun a (fun (fun a b) b)))))
  (define applyTo
    (abs a (abs b
      (lam x (lam f
        [f x])))))
  
  
  (declare compose
    (forall a (type) (forall b (type) (forall c (type)
      (fun (fun b c)
           (fun (fun a b)
                (fun a c)))))))
  (define compose
    (abs a (abs b (abs c
      (lam f (lam g (lam x
        [f [g x]])))))))
  
  
  (declare compose2
    (forall a (type) (forall b (type) (forall c (type) (forall d (type)
      (fun (fun c d)
           (fun (fun a (fun b c))
                (fun a (fun b d)))))))))
  (define compose2
    (abs a (abs b (abs c (abs d
      (lam f (lam g (lam x (lam y
        [f [g x y]])))))))))
  
  
  
  ;;
  ;; Unit Tools
  ;;
  
  (data Unit () (MkUnit))
  
  
  
  ;;
  ;; Boolean Tools
  ;;
  
  (data Bool () (True) (False))
  
  (declare equalsBool
    (fun (con Bool)
      (fun (con Bool)
           (con Bool))))
  (define equalsBool (lam x (lam y
    (case x
      (True ()
        (case y
          (True () (con True))
          (False () (con False))))
      (False ()
        (case y
          (True () (con False))
          (False () (con True))))))))
  
  (declare not
    (fun (con Bool) (con Bool)))
  (define not
    (lam x
      (case x
        (True ()
          (con False))
        (False ()
          (con True)))))
  
  
  (declare and
    (fun (con Bool)
         (fun (con Bool)
              (con Bool))))
  (define and
    (lam x (lam y
      (case x
        (True () y)
        (False ()
          (con False))))))
  
  
  (declare or
    (fun (con Bool)
         (fun (con Bool)
              (con Bool))))
  (define or
    (lam x (lam y
      (case x
        (True ()
          (con True))
        (False () y)))))
  
  
  (declare bool
    (forall a (type)
      (fun a (fun a (fun (con Bool) a)))))
  (define bool
    (abs a
      (lam f (lam t (lam b
        (case b
          (True  () t)
          (False () f)))))))
  
  
  
  
  ;;
  ;; Pair Tools
  ;;
  
  (data Pair ((a (type)) (b (type)))
        (MkPair a b))
  
  (declare equalsPair
    (forall a (type) (forall b (type)
      (fun (fun a (fun a (con Bool)))
        (fun (fun b (fun b (con Bool)))
          (fun (con Pair a b)
            (fun (con Pair a b)
                 (con Bool))))))))
  (define equalsPair (abs a (abs b (lam eqA (lam eqB (lam p1 (lam p2
    (case p1
      (MkPair (x1 y1)
        (case p2
          (MkPair (x2 y2)
            [and [eqA x1 x2] [eqB y1 y2]])))))))))))
  
  
  (declare fst
    (forall a (type) (forall b (type)
      (fun (con Pair a b) a))))
  (define fst
    (abs a (abs b
      (lam p
        (case p
          (MkPair (x y) x))))))
  
  
  (declare snd
    (forall a (type) (forall b (type)
      (fun (con Pair a b) b))))
  (define snd
    (abs a (abs b
      (lam p
        (case p
          (MkPair (x y) y))))))
  
  
  (declare curry
    (forall a (type) (forall b (type) (forall c (type)
      (fun (fun (con Pair a b) c)
           (fun a (fun b c)))))))
  (define curry
    (abs a (abs b (abs c
      (lam f (lam x (lam y
        [f (con MkPair x y)])))))))
  
  
  (declare uncurry
    (forall a (type) (forall b (type) (forall c (type)
      (fun (fun a (fun b c))
           (fun (con Pair a b) c))))))
  (define uncurry
    (abs a (abs b (abs c
      (lam f (lam p
        (case p
          (MkPair (x y) [f x y]))))))))
  
  
  (declare swap
    (forall a (type) (forall b (type)
      (fun (con Pair a b)
           (con Pair b a)))))
  (define swap
    (abs a (abs b
      (lam p
        (case p
          (MkPair (x y)
            (con MkPair y x)))))))
  
  
  
  
  
  ;;
  ;; Integer Tools
  ;;
  
  (declare addInteger
    (fun (integer) (fun (integer) (integer))))
  (define addInteger
    (lam x (lam y
      (builtin addInteger x y))))
  
  
  (declare subtractInteger
    (fun (integer) (fun (integer) (integer))))
  (define subtractInteger
    (lam x (lam y
      (builtin subtractInteger x y))))
  
  
  (declare multiplyInteger
    (fun (integer) (fun (integer) (integer))))
  (define multiplyInteger
    (lam x (lam y
      (builtin multiplyInteger x y))))
  
  
  (declare divideInteger
    (fun (integer) (fun (integer) (integer))))
  (define divideInteger
    (lam x (lam y
      (builtin divideInteger x y))))
  
  
  (declare remainderInteger
    (fun (integer) (fun (integer) (integer))))
  (define remainderInteger
    (lam x (lam y
      (builtin remainderInteger x y))))
  
  
  (declare equalsInteger
    (fun (integer) (fun (integer) (con Bool))))
  (define equalsInteger
    (lam x (lam y
      (builtin equalsInteger x y))))
  
  
  (declare lessThanInteger
    (fun (integer) (fun (integer) (con Bool))))
  (define lessThanInteger
    (lam x (lam y
      (builtin lessThanInteger x y))))
  
  
  (declare greaterThanInteger
    (fun (integer) (fun (integer) (con Bool))))
  (define greaterThanInteger
    (lam x (lam y
      (builtin lessThanInteger y x))))
  
  
  (declare lessThanEqualsInteger
    (fun (integer) (fun (integer) (con Bool))))
  (define lessThanEqualsInteger
    (lam x (lam y
      (builtin lessThanEqualsInteger x y))))
  
  
  (declare greaterThanEqualsInteger
    (fun (integer) (fun (integer) (con Bool))))
  (define greaterThanEqualsInteger
    (lam x (lam y
      (builtin lessThanEqualsInteger y x))))
  
  
  (declare maxInteger
    (fun (integer) (fun (integer) (integer))))
  (define maxInteger
    (lam x (lam y
      (case [lessThanInteger x y]
        (True () y)
        (False () x)))))
  
  
  (declare minInteger
    (fun (integer) (fun (integer) (integer))))
  (define minInteger
    (lam x (lam y
      (case [lessThanInteger x y]
        (True () x)
        (False () y)))))
  
  
  (declare integerToFloat
    (fun (integer) (float)))
  (define integerToFloat
    (lam x
      (builtin integerToFloat x)))
  
  
  (declare integerToByteString
    (fun (integer) (bytestring)))
  (define integerToByteString
    (lam x
      (builtin integerToByteString x)))
  
  
  
  ;;
  ;; Float Tools
  ;;
  
  (declare addFloat
    (fun (float) (fun (float) (float))))
  (define addFloat
    (lam x (lam y
      (builtin addFloat x y))))
  
  
  (declare subtractFloat
    (fun (float) (fun (float) (float))))
  (define subtractFloat
    (lam x (lam y
      (builtin subtractFloat x y))))
  
  
  (declare multiplyFloat
    (fun (float) (fun (float) (float))))
  (define multiplyFloat
    (lam x (lam y
      (builtin multiplyFloat x y))))
  
  
  (declare divideFloat
    (fun (float) (fun (float) (float))))
  (define divideFloat
    (lam x (lam y
      (builtin divideFloat x y))))
  
  
  (declare equalsFloat
    (fun (float) (fun (float) (con Bool))))
  (define equalsFloat
    (lam x (lam y
      (builtin equalsFloat x y))))
  
  
  (declare lessThanFloat
    (fun (float) (fun (float) (con Bool))))
  (define lessThanFloat
    (lam x (lam y
      (builtin lessThanFloat x y))))
  
  
  (declare greaterThanFloat
    (fun (float) (fun (float) (con Bool))))
  (define greaterThanFloat
    (lam x (lam y
      (builtin lessThanFloat y x))))
  
  
  (declare lessThanEqualsFloat
    (fun (float) (fun (float) (con Bool))))
  (define lessThanEqualsFloat
    (lam x (lam y
      (builtin lessThanEqualsFloat x y))))
  
  
  (declare greaterThanEqualsFloat
    (fun (float) (fun (float) (con Bool))))
  (define greaterThanEqualsFloat
    (lam x (lam y
      (builtin lessThanEqualsFloat y x))))
  
  
  (declare ceil
    (fun (float) (integer)))
  (define ceil
    (lam x
      (builtin ceil x)))
  
  
  (declare floor
    (fun (float) (integer)))
  (define floor
    (lam x
      (builtin floor x)))
  
  
  (declare maxFloat
    (fun (float) (fun (float) (float))))
  (define maxFloat
    (lam x (lam y
      (case [lessThanFloat x y]
        (True () y)
        (False () x)))))
  
  
  (declare minFloat
    (fun (float) (fun (float) (float))))
  (define minFloat
    (lam x (lam y
      (case [lessThanFloat x y]
        (True () x)
        (False () y)))))
  
  
  
  ;;
  ;; ByteString Tools
  ;;
  
  (declare concatenate
    (fun (bytestring) (fun (bytestring) (bytestring))))
  (define concatenate
    (lam x (lam y
      (builtin concatenate x y))))
  
  
  (declare takeByteString
    (fun (integer) (fun (bytestring) (bytestring))))
  (define takeByteString
    (lam n (lam x
      (builtin takeByteString n x))))
  
  
  (declare dropByteString
    (fun (integer) (fun (bytestring) (bytestring))))
  (define dropByteString
    (lam n (lam x
      (builtin dropByteString n x))))
  
  
  (declare sha2_256
    (fun (bytestring) (bytestring)))
  (define sha2_256
    (lam x
      (builtin sha2_256 x)))
  
  
  (declare sha3_256
    (fun (bytestring) (bytestring)))
  (define sha3_256
    (lam x
      (builtin sha3_256 x)))
  
  
  (declare equalsByteString
    (fun (bytestring) (fun (bytestring) (con Bool))))
  (define equalsByteString
    (lam x (lam y
      (builtin equalsByteString x y))))
  
  
  
  ;;
  ;; Maybe Tools
  ;;
  
  (data Maybe ((a (type)))
        (Nothing)
        (Just a))
  
  
  (declare maybe
    (forall a (type) (forall b (type)
      (fun b (fun (fun a b) (fun (con Maybe a) b))))))
  (define maybe
    (abs a (abs b
      (lam n (lam j (lam m
        (case m
          (Nothing () n)
          (Just (x) [j x]))))))))
  
  
  (declare isJust
    (forall a (type)
      (fun (con Maybe a) (con Bool))))
  (define isJust
    (abs a
      (lam m
        (case m
          (Nothing ()
            (con False))
          (Just (x)
            (con True))))))
  
  
  (declare isNothing
    (forall a (type)
      (fun (con Maybe a) (con Bool))))
  (define isNothing
    (abs a
      (lam m
        (case m
          (Nothing ()
            (con True))
          (Just (x)
            (con False))))))
  
  
  (declare fromMaybe
    (forall a (type)
      (fun a (fun (con Maybe a) a))))
  (define fromMaybe
    (abs a
      (lam n (lam m
        (case m
          (Nothing () n)
          (Just (x) x))))))
  
  
  (declare mapMaybe
    (forall a (type) (forall b (type)
      (fun (fun a b)
           (fun (con Maybe a)
                (con Maybe b))))))
  (define mapMaybe
    (abs a (abs b
      (lam f (lam m
        (case m
          (Nothing ()
            (con Nothing))
          (Just (x)
            (con Just [f x]))))))))
  
  
  (declare equalsMaybe
    (forall a (type)
      (fun (fun a (fun a (con Bool)))
        (fun (con Maybe a)
          (fun (con Maybe a)
            (con Bool))))))
  (define equalsMaybe
    (abs a (lam eq (lam m (lam m'
      (case m
        (Nothing ()
          (case m'
            (Nothing ()
              (con True))
            (Just (y)
              (con False))))
        (Just (x)
          (case m'
            (Nothing ()
              (con False))
            (Just (y) [eq x y])))))))))
  
  
  
  ;;
  ;; Either Tools
  ;;
  
  (data Either ((a (type)) (b (type)))
        (Left a)
        (Right b))
  
  
  (declare either
    (forall a (type) (forall b (type) (forall c (type)
      (fun (fun a c)
           (fun (fun b c)
                (fun (con Either a b) c)))))))
  (define either
    (abs a (abs b (abs c
      (lam f (lam g (lam e
        (case e
          (Left (x) [f x])
          (Right (y) [g y])))))))))
  
  
  (declare isLeft
    (forall a (type) (forall b (type)
      (fun (con Either a b) (con Bool)))))
  (define isLeft
    (abs a (abs b
      (lam e
        (case e
          (Left (x)
            (con True))
          (Right (y)
            (con False)))))))
  
  
  (declare isRight
    (forall a (type) (forall b (type)
      (fun (con Either a b) (con Bool)))))
  (define isRight
    (abs a (abs b
      (lam e
        (case e
          (Left (x)
            (con False))
          (Right (y)
            (con True)))))))
  
  
  (declare eitherToMaybe
    (forall a (type) (forall b (type)
      (fun (con Either a b)
           (con Maybe b)))))
  (define eitherToMaybe
    (abs a (abs b
      (lam e
        (case e
          (Left (x)
            (con Nothing))
          (Right (y)
            (con Just y)))))))
  
  
  (declare maybeToEither
    (forall a (type) (forall b (type)
      (fun a
        (fun (con Maybe b)
             (con Either a b))))))
  (define maybeToEither
    (abs a (abs b
      (lam x (lam m
        (case m
          (Nothing ()
            (con Left x))
          (Just (y)
            (con Right y))))))))
  
  
  (declare equalsEither
    (forall a (type) (forall b (type)
      (fun (fun a (fun a (con Bool)))
        (fun (fun b (fun b (con Bool)))
          (fun (con Either a b)
            (fun (con Either a b)
              (con Bool))))))))
  (define equalsEither
    (abs a (abs b (lam eqA (lam eqB (lam e (lam e'
      (case e
        (Left (x)
          (case e'
            (Left (x') [eqA x x'])
            (Right (y')
              (con False))))
        (Right (y)
          (case e'
            (Left (x')
              (con False))
            (Right (y') [eqB y y'])))))))))))
  
  
  
  ;;
  ;; List Tools
  ;;
  
  (data List ((a (type)))
        (Nil)
        (Cons a (con List a)))
  
  
  (declare equalsList
    (forall a (type)
      (fun (fun a (fun a (con Bool)))
        (fun (con List a)
          (fun (con List a)
            (con Bool))))))
  (define equalsList
    (abs a (lam eqA (lam xs (lam ys
      (case xs
        (Nil ()
          (case ys
            (Nil ()
              (con True))
            (Cons (y ys')
              (con False))))
        (Cons (x xs')
          (case ys
            (Nil ()
              (con False))
            (Cons (y ys')
              [and
                [eqA x y]
                [(inst equalsList a) eqA xs' ys']])))))))))
  
  
  (declare append
    (forall a (type)
      (fun (con List a)
           (fun (con List a)
                (con List a)))))
  (define append
    (abs a
      (lam xs (lam ys
        (case xs
          (Nil () ys)
          (Cons (x xs')
            (con Cons
                 x
                 [(inst append a) xs' ys])))))))
  
  
  (declare head
    (forall a (type)
      (fun (con List a) (con Maybe a))))
  (define head
    (abs a
      (lam xs
        (case xs
          (Nil ()
            (con Nothing))
          (Cons (x xs')
            (con Just x))))))
  
  
  (declare last
    (forall a (type)
      (fun (con List a) (con Maybe a))))
  (define last
    (abs a
      (lam xs
        (case xs
          (Nil ()
            (con Nothing))
          (Cons (x xs')
            (case xs'
              (Nil ()
                (con Just x))
              (Cons (x' xs'')
                [(inst last a)
                  (con Cons x' xs'')])))))))
  
  
  (declare tail
    (forall a (type)
      (fun (con List a)
           (con Maybe (con List a)))))
  (define tail
    (abs a
      (lam xs
        (case xs
          (Nil ()
            (con Nothing))
          (Cons (x xs)
            (con Just xs))))))
  
  
  (declare init
    (forall a (type)
      (fun (con List a)
           (con Maybe (con List a)))))
  (define init
    (abs a
      (lam xs
        (case xs
          (Nil ()
            (con Nothing))
          (Cons (x xs)
            (case [(inst init a) xs]
              (Nothing ()
                (con Just (con Nil)))
              (Just (ys)
                (con Just (con Cons x ys)))))))))
  
  
  (declare uncons
    (forall a (type)
      (fun (con List a)
           (con Maybe (con Pair a (con List a))))))
  (define uncons
    (abs a
      (lam xs
        (case xs
          (Nil ()
            (con Nothing))
          (Cons (x xs)
            (con Just (con MkPair x xs)))))))
  
  
  (declare null
    (forall a (type)
      (fun (con List a) (con Bool))))
  (define null
    (abs a
      (lam xs
        (case xs
          (Nil ()
            (con True))
          (Cons (x xs)
            (con False))))))
  
  
  (declare length
    (forall a (type)
      (fun (con List a) (integer))))
  (define length
    (abs a
      (lam xs
        (case xs
          (Nil () 0)
          (Cons (x xs)
            [addInteger 1
              [(inst length a) xs]])))))
  
  
  (declare elem
    (forall a (type)
      (fun (fun a (fun a (con Bool)))
        (fun a
          (fun (con List a)
               (con Bool))))))
  (define elem (abs a (lam eqA (lam x (lam xs
    (case xs
      (Nil () (con False))
      (Cons (y ys)
        (case [eqA x y]
          (True () (con True))
          (False ()
            [(inst elem a) eqA x ys])))))))))
  
  
  (declare take
    (forall a (type)
      (fun (integer)
           (fun (con List a)
                (con List a)))))
  (define take
    (abs a
      (lam n (lam xs
        (case [equalsInteger n 0]
          (True ()
            (con Nil))
          (False ()
            (case xs
              (Nil ()
                (con Nil))
              (Cons (x xs')
                (con Cons
                    x
                    [(inst take a)
                      [subtractInteger n 1] xs'])))))))))
  
  
  (declare drop
    (forall a (type)
      (fun (integer)
           (fun (con List a)
                (con List a)))))
  (define drop
    (abs a
      (lam n (lam xs
        (case [equalsInteger n 0]
          (True () xs)
          (False ()
            (case xs
              (Nil ()
                (con Nil))
              (Cons (x xs')
                [(inst drop a)
                  [subtractInteger n 1]
                  xs']))))))))
  
  
  (declare splitAt
    (forall a (type)
      (fun (integer)
           (fun (con List a)
                (con Pair
                     (con List a)
                     (con List a))))))
  (define splitAt
    (abs a
      (lam n (lam xs
        (case [equalsInteger n 0]
          (True ()
            (con MkPair (con Nil) xs))
          (False ()
            (case xs
              (Nil ()
                (con MkPair
                     (con Nil)
                     (con Nil)))
              (Cons (x xs')
                (case [(inst splitAt a)
                        [subtractInteger n 1] xs']
                  (MkPair (ys zs)
                    (con MkPair
                         (con Cons x ys) zs)))))))))))
  
  
  (declare takeWhile
    (forall a (type)
      (fun (fun a (con Bool))
           (fun (con List a)
                (con List a)))))
  (define takeWhile
    (abs a
      (lam p (lam xs
        (case xs
          (Nil ()
            (con Nil))
          (Cons (x xs')
            (case [p x]
              (True ()
                (con Cons
                    x
                    [(inst takeWhile a) p xs']))
              (False ()
                (con Nil)))))))))
  
  
  (declare dropWhile
    (forall a (type)
      (fun (fun a (con Bool))
           (fun (con List a)
                (con List a)))))
  (define dropWhile
    (abs a
      (lam p (lam xs
        (case xs
          (Nil () 
            (con Nil))
          (Cons (x xs')
            (case [p x]
              (True ()
                [(inst dropWhile a) p xs'])
              (False ()
                (con Cons x xs')))))))))
  
  
  (declare span
    (forall a (type)
      (fun (fun a (con Bool))
           (fun (con List a)
                (con Pair
                  (con List a)
                  (con List a))))))
  (define span
    (abs a
      (lam p (lam xs
        (case xs
          (Nil ()
            (con MkPair
                 (con Nil)
                 (con Nil)))
          (Cons (x xs')
            (case [p x]
              (True ()
                (case [(inst span a) p xs']
                  (MkPair (ys zs)
                    (con MkPair
                         (con Cons x ys)
                         zs))))
              (False ()
                (con MkPair
                     (con Nil)
                     (con Cons x xs'))))))))))
  
  
  (declare groupBy
    (forall a (type)
      (fun (fun a (fun a (con Bool)))
           (fun (con List a)
                (con List (con List a))))))
  (define groupBy
    (abs a
      (lam eq (lam xs
        (case xs
          (Nil ()
            (con Nil))
          (Cons (x xs')
            (case [(inst span a) [eq x] xs']
              (MkPair
                (ys zs)
                (con Cons
                     (con Cons x ys)
                     [(inst groupBy a) eq zs])))))))))
  
  
  (declare foldr
    (forall a (type) (forall b (type)
      (fun (fun a (fun b b))
           (fun b
                (fun (con List a)
                     b))))))
  (define foldr
    (abs a (abs b
      (lam c (lam n (lam xs
        (case xs
          (Nil () n)
          (Cons (x xs')
            [c x [(inst (inst foldr a) b) c n xs']]))))))))
  
  
  (declare foldl
    (forall a (type) (forall b (type)
      (fun (fun b (fun a b))
           (fun b
                (fun (con List a)
                     b))))))
  (define foldl
    (abs a (abs b
      (lam s (lam n (lam xs
        (case xs
          (Nil () n)
          (Cons (x xs')
            [(inst (inst foldl a) b) s [s n x] xs']))))))))
  
  
  (declare unfoldr
    (forall a (type) (forall b (type)
      (fun (fun b (con Maybe (con Pair a b)))
           (fun b (con List a))))))
  (define unfoldr
    (abs a (abs b
      (lam step (lam s
        (case [step s]
          (Nothing ()
            (con Nil))
          (Just (p)
            (case p
              (MkPair (x s')
                (con Cons
                     x
                     [(inst (inst unfoldr a) b) step s']))))))))))
  
  
  (declare replicate
    (forall a (type)
      (fun (integer) (fun a (con List a)))))
  (define replicate
    (abs a
      (lam n (lam x
        (case [equalsInteger n 0]
          (True ()
            (con Nil))
          (False ()
            (con Cons
                 x
                 [(inst replicate a)
                   [subtractInteger n 1]
                   x])))))))
  
  
  (declare map
    (forall a (type) (forall b (type)
      (fun (fun a b)
           (fun (con List a) (con List b))))))
  (define map
    (abs a (abs b
      (lam f (lam xs
        (case xs
          (Nil ()
            (con Nil))
          (Cons (x xs')
            (con Cons
                 [f x]
                 [(inst (inst map a) b) f xs']))))))))
  
  
  (declare reverseOnto
    (forall a (type)
      (fun (con List a)
           (fun (con List a)
                (con List a)))))
  (define reverseOnto
    (abs a
      (lam xs (lam ys
        (case xs
          (Nil () ys)
          (Cons (x xs')
            [(inst reverseOnto a) xs' (con Cons x ys)]))))))
  
  
  (declare reverse
    (forall a (type) (fun (con List a) (con List a))))
  (define reverse
    (abs a
      (lam xs [(inst reverseOnto a) xs (con Nil)])))
  
  
  (declare prependToAll
    (forall a (type)
      (fun a
           (fun (con List a)
                (con List a)))))
  (define prependToAll
    (abs a
      (lam sep (lam xs
        (case xs
          (Nil ()
            (con Cons sep (con Nil)))
          (Cons (x xs')
            (con Cons
                 sep
                 (con Cons
                      x
                      [(inst prependToAll a) sep xs']))))))))
  
  
  (declare intersperse
    (forall a (type)
      (fun a
           (fun (con List a)
                (con List a)))))
  (define intersperse
    (abs a
      (lam sep (lam xs
        (case xs
          (Nil ()
            (con Nil))
          (Cons (x xs')
            (con Cons
                 x
                 [(inst prependToAll a) sep xs'])))))))
  
  
  (declare concat
    (forall a (type)
      (fun (con List (con List a))
           (con List a))))
  (define concat
    (abs a
      (lam xss
        (case xss
          (Nil ()
            (con Nil))
          (Cons (xs xss')
            [(inst append a) xs [(inst concat a) xss']])))))
  
  
  (declare concatMap
    (forall a (type) (forall b (type)
      (fun (fun a (con List b))
           (fun (con List a)
                (con List b))))))
  (define concatMap
    (abs a (abs b
      (lam f (lam xs
        (case xs
          (Nil ()
            (con Nil))
          (Cons (x xs')
            [(inst append b) [f x] [(inst (inst concatMap a) b) f xs']])))))))
  
  
  (declare intercalate
    (forall a (type)
      (fun (con List a)
           (fun (con List (con List a))
                (con List a)))))
  (define intercalate
    (abs a
      (lam xs (lam xss
        [(inst concat a)
          [(inst intersperse (con List a))
            xs
            xss]]))))
  
  
  (declare filter
    (forall a (type)
      (fun (fun a (con Bool))
           (fun (con List a)
                (con List a)))))
  (define filter
    (abs a
      (lam p (lam xs
        (case xs
          (Nil ()
            (con Nil))
          (Cons (x xs')
            (case [p x]
              (True ()
                (con Cons x [(inst filter a) p xs']))
              (False () [(inst filter a) p xs']))))))))
  
  
  (declare find
    (forall a (type)
      (fun (fun a (con Bool))
           (fun (con List a)
                (con Maybe a)))))
  (define find
    (abs a
      (lam p (lam xs
        (case xs
          (Nil ()
            (con Nothing))
          (Cons (x xs')
            (case [p x]
              (True ()
                (con Just x))
              (False () [(inst find a) p xs']))))))))
  
  
  (declare partition
    (forall a (type)
      (fun (fun a (con Bool))
           (fun (con List a)
                (con Pair
                     (con List a)
                     (con List a))))))
  (define partition
    (abs a
      (lam p (lam xs
        (case xs
          (Nil ()
            (con MkPair (con Nil) (con Nil)))
          (Cons (x xs')
            (case [(inst partition a) p xs']
              (MkPair (ts fs)
                (case [p x]
                  (True ()
                    (con MkPair (con Cons x ts) fs))
                  (False ()
                    (con MkPair ts (con Cons x fs))))))))))))
  
  
  (declare nubBy
    (forall a (type)
      (fun (fun a (fun a (con Bool)))
           (fun (con List a)
                (con List a)))))
  (define nubBy
    (abs a
      (lam comp (lam xs
        (case xs
          (Nil ()
            (con Nil))
          (Cons (x xs')
            (con Cons
                 x
                 [(inst filter a)
                   (lam y [not [comp x y]])
                   [(inst nubBy a) comp xs']])))))))
  
  
  (declare zipWith
    (forall a (type) (forall b (type) (forall c (type)
      (fun (fun a (fun b c))
           (fun (con List a)
                (fun (con List b)
                     (con List c))))))))
  (define zipWith
    (abs a (abs b (abs c
      (lam f (lam xs (lam ys
        (case xs
          (Nil ()
            (con Nil))
          (Cons (x xs')
            (case ys
              (Nil ()
                (con Nil))
              (Cons (y ys')
                (con Cons
                     [f x y]
                     [(inst (inst (inst zipWith a) b) c)
                       f xs' ys']))))))))))))
  
  
  (declare zip
    (forall a (type) (forall b (type)
      (fun (con List a)
           (fun (con List b)
                (con List (con Pair a b)))))))
  (define zip
    (abs a (abs b
      (lam xs (lam ys
        [(inst (inst (inst zipWith a) b) (con Pair a b)) (lam x (lam y (con MkPair x y))) xs ys])))))
  
  
  (declare unzip
    (forall a (type) (forall b (type)
      (fun (con List (con Pair a b))
           (con Pair (con List a)
                             (con List b))))))
  (define unzip
    (abs a (abs b
      (lam xys
        (case xys
          (Nil ()
            (con MkPair (con Nil) (con Nil)))
          (Cons (xy xys')
            (case xy
              (MkPair (x y)
                (case [(inst (inst unzip a) b) xys']
                  (MkPair (xs ys)
                    (con MkPair
                         (con Cons x xs)
                         (con Cons y ys))))))))))))
  
  
  (declare andList
    (fun (con List (con Bool)) (con Bool)))
  (define andList
    (lam bs
      [(inst (inst foldl (con Bool)) (con Bool))
        and
        (con True)
        bs]))
  
  
  (declare orList
    (fun (con List (con Bool)) (con Bool)))
  (define orList
    (lam bs
      [(inst (inst foldl (con Bool)) (con Bool))
        or
        (con False)
        bs]))
  
  
  (declare any
    (forall a (type)
      (fun (fun a (con Bool))
           (fun (con List a)
                (con Bool)))))
  (define any
    (abs a
      (lam p (lam xs [orList [(inst (inst map a) (con Bool)) p xs]]))))
  
  
  (declare all
    (forall a (type)
      (fun (fun a (con Bool))
           (fun (con List a)
                (con Bool)))))
  (define all
    (abs a
      (lam p (lam xs [andList [(inst (inst map a) (con Bool)) p xs]]))))
  
  
  (declare sumInteger
    (fun (con List (integer)) (integer)))
  (define sumInteger
    (lam xs
      [(inst (inst foldl (integer)) (integer))
        addInteger 0 xs]))
  
  
  (declare sumFloat
    (fun (con List (float)) (float)))
  (define sumFloat
    (lam xs [(inst (inst foldl (float)) (float))
      addFloat 0.0 xs]))
  
  (declare productInteger
    (fun (con List (integer)) (integer)))
  (define productInteger
    (lam xs
      [(inst (inst foldl (integer)) (integer))
        multiplyInteger 1 xs]))
  
  
  (declare productFloat
    (fun (con List (float)) (float)))
  (define productFloat
    (lam xs
      [(inst (inst foldl (float)) (float))
        multiplyFloat 1.0 xs]))
  
  (declare maximumBy
    (forall a (type)
      (fun (fun a (fun a (con Bool)))
           (fun a
                (fun (con List a)
                     a)))))
  (define maximumBy
    (abs a
      (lam comp (lam m
        [(inst (inst foldl a) a)
          (lam x (lam y
            (case [comp x y]
              (True () y)
              (False () x))))
          m]))))
  
  
  (declare minimumBy
    (forall a (type)
      (fun (fun a (fun a (con Bool)))
           (fun a
                (fun (con List a)
                     a)))))
  (define minimumBy
    (abs a
      (lam comp (lam m
        [(inst (inst foldl a) a)
          (lam x (lam y
            (case [comp x y]
              (True () x)
              (False () y))))
          m]))))
  
  
  (declare project
    (forall a (type)
      (fun (con List a)
           (fun (integer)
                (con Maybe a)))))
  (define project
    (abs a
      (lam xs (lam n
        (case xs
          (Nil ()
            (con Nothing))
          (Cons (x xs')
            (case [equalsInteger n 0]
              (True ()
                (con Just x))
              (False ()
                [(inst project a)
                  xs'
                  [subtractInteger n 1]]))))))))
  
  
  (declare findIndex
    (forall a (type)
      (fun (fun a (con Bool))
           (fun (con List a)
                (con Maybe (integer))))))
  (define findIndex
    (abs a
      (lam p (lam xs
        (case xs
          (Nil ()
            (con Nothing))
          (Cons (x xs')
            (case [p x]
              (True ()
                (con Just 0))
              (False ()
                (case [(inst findIndex a) p xs']
                  (Nothing ()
                    (con Nothing))
                  (Just (i)
                    (con Just [addInteger i 1])))))))))))
  
  
  (declare findIndicesFrom
    (forall a (type)
      (fun (integer)
           (fun (fun a (con Bool))
                (fun (con List a)
                     (con List (integer)))))))
  (define findIndicesFrom
    (abs a
      (lam i (lam p (lam xs
        (case xs
          (Nil ()
            (con Nil))
          (Cons (x xs')
            (case [p x]
              (True ()
                (con Cons
                     i
                     [(inst findIndicesFrom a)
                       [addInteger i 1]
                       p
                       xs]))
              (False ()
                [(inst findIndicesFrom a)
                  [addInteger i 1]
                  p
                  xs])))))))))
  
  
  (declare findIndices
    (forall a (type)
      (fun (con List a)
           (fun (fun a (con Bool))
                (con List (integer))))))
  (define findIndices
    (abs a
      (lam xs (lam p [(inst findIndicesFrom a) 0 p xs]))))
  
  
  (declare evenOddSplitFrom
    (forall a (type)
      (fun (con Bool)
           (fun (con List a)
                (con Pair
                     (con List a)
                     (con List a))))))
  (define evenOddSplitFrom
    (abs a
      (lam b (lam xs
        (case xs
          (Nil ()
            (con MkPair (con Nil) (con Nil)))
          (Cons (x xs')
            (case [(inst evenOddSplitFrom a) [not b] xs']
              (MkPair (es os)
                (case b
                  (True ()
                    (con MkPair (con Cons x es) os))
                  (False ()
                    (con MkPair es (con Cons x os))))))))))))
  
  
  (declare evenOddSplit
    (forall a (type)
      (fun (con List a)
           (con Pair
                (con List a)
                (con List a)))))
  (define evenOddSplit
    (abs a
      (lam xs [(inst evenOddSplitFrom a) (con True) xs])))
  
  
  (declare mergeBy
    (forall a (type)
      (fun (fun a (fun a (con Bool)))
           (fun (con List a)
                (fun (con List a)
                     (con List a))))))
  (define mergeBy
    (abs a
      (lam comp (lam xs (lam ys
        (case xs
          (Nil () ys)
          (Cons (x xs')
            (case ys
              (Nil ()
                (con Cons x xs'))
              (Cons (y ys')
                (case [comp x y]
                  (True ()
                    (con Cons
                         x
                         [(inst mergeBy a)
                           comp
                           xs'
                           (con Cons y ys')]))
                  (False ()
                    (con Cons
                         y
                         [(inst mergeBy a)
                           comp
                           (con Cons x xs')
                           ys']))))))))))))
  
  
  (declare mergeSortBy
    (forall a (type)
      (fun (fun a (fun a (con Bool)))
           (fun (con List a)
                (con List a)))))
  (define mergeSortBy
    (abs a
      (lam comp (lam xs
        (case [(inst evenOddSplit a) xs]
          (MkPair (es os)
            [(inst mergeBy a)
              comp
              [(inst mergeSortBy a) comp es]
              [(inst mergeSortBy a) comp os]]))))))
  
  
  (declare quickSortBy
    (forall a (type)
      (fun (fun a (fun a (con Bool)))
           (fun (con List a)
                (con List a)))))
  (define quickSortBy
    (abs a
      (lam comp (lam xs
        (case xs
          (Nil ()
            (con Nil))
          (Cons (x xs')
            (case [(inst partition a) [comp x] xs']
              (MkPair (lo hi)
                [(inst append a)
                  [(inst quickSortBy a) comp lo]
                  (con Cons x [(inst quickSortBy a) comp hi])]))))))))

  
  (declare listToMaybe
    (forall a (type)
      (fun (con List a) (con Maybe a))))
  (define listToMaybe
    (abs a
      (lam xs
        (case xs
          (Nil ()
            (con Nothing))
          (Cons (x xs')
            (con Just x))))))
  
  
  (declare maybeToList
    (forall a (type)
      (fun (con Maybe a) (con List a))))
  (define maybeToList
    (abs a
      (lam m
        (case m
          (Nothing ()
            (con Nil))
          (Just (x)
            (con Cons x (con Nil)))))))
  
  
  (declare catMaybes
    (forall a (type)
      (fun (con List (con Maybe a))
           (con List a))))
  (define catMaybes
    (abs a
      (lam ms
        (case ms
          (Nil ()
            (con Nil))
          (Cons (m ms')
            (case m
              (Nothing () [(inst catMaybes a) ms'])
              (Just (x)
                (con Cons x [(inst catMaybes a) ms']))))))))
  
  
  (declare lefts
    (forall a (type) (forall b (type)
      (fun (con List (con Either a b))
           (con List a)))))
  (define lefts
    (abs a (abs b
      (lam es
        (case es
          (Nil ()
            (con Nil))
          (Cons (e es')
            (case e
              (Left (x)
                (con Cons x [(inst (inst lefts a) b) es']))
              (Right (y) [(inst (inst lefts a) b) es']))))))))
  
  
  (declare rights
    (forall a (type) (forall b (type)
      (fun (con List (con Either a b))
           (con List b)))))
  (define rights
    (abs a (abs b
      (lam es
        (case es
          (Nil ()
            (con Nil))
          (Cons (e es')
            (case e
              (Left (x) [(inst (inst rights a) b) es'])
              (Right (y)
                (con Cons y [(inst (inst rights a) b) es'])))))))))
  
  
  (declare partitionEithers
    (forall a (type) (forall b (type)
      (fun (con List (con Either a b))
           (con Pair
                (con List a)
                (con List b))))))
  (define partitionEithers
    (abs a (abs b
      (lam es
        (case es
          (Nil ()
            (con MkPair (con Nil) (con Nil)))
          (Cons (e es')
            (case [(inst (inst partitionEithers a) b) es']
              (MkPair (ls rs)
                (case e
                  (Left (x)
                    (con MkPair (con Cons x ls) rs))
                  (Right (y)
                    (con MkPair ls (con Cons y rs))))))))))))
  
  
  
  ;;
  ;; Blockchain Tools
  ;;
  
  
  ;; (declare verifySignature
  ;;   (fun (bytestring)
  ;;     (fun (bytestring)
  ;;       (fun (bytestring)
  ;;            (con Bool)))))
  ;; (define verifySignature
  ;;   (lam k (lam dat (lam s
  ;;     (builtin verifySignature k dat s)))))
  ;; 
  ;; 
  ;; (declare verify
  ;;   (fun (bytestring)
  ;;        (fun (bytestring)
  ;;             (fun (con Maybe (bytestring))
  ;;                  (con Bool)))))
  ;; (define verify
  ;;   (lam dat (lam k (lam m
  ;;     (case m
  ;;       (cl Nil () (con False))
  ;;       (cl Just (s) [verifySignature k dat s]))))))
  ;; 
  ;; 
  ;; (declare verifyMultiSig
  ;;   (fun (integer)
  ;;     (fun (con List (bytestring))
  ;;       (fun (bytestring)
  ;;         (fun (con List (con Maybe (bytestring)))
  ;;           (comp (con Unit)))))))
  ;; (define verifyMultiSig
  ;;   (lam n (lam keys (lam dat (lam sigs
  ;;     (case [and
  ;;             [equalsInt
  ;;               [(inst length (con List (bytestring))) keys]
  ;;               [(inst length (con List (con Maybe (bytestring)))) sigs]]
  ;;             [lessThanEqualsInt
  ;;               n
  ;;               [(inst length (con Bool))
  ;;                 [(inst filter (con Bool)) (inst id Bool)
  ;;                   [(inst (inst (inst zipWith (bytestring)) (con Maybe (bytestring))) (con Bool))
  ;;                     [verify dat]
  ;;                     keys
  ;;                     sigs]]]]]
  ;;       (True () (success (con MkUnit)))
  ;;       (False () (failure))))))))
  
  
  (data MASTProp ()
    (MASTTrue)
    (MASTFalse)
    (MASTNot (con MASTProp))
    (MASTAnd (con MASTProp) (con MASTProp))
    (MASTOr (con MASTProp) (con MASTProp)))
  
  
  (declare evalMASTProp
    (fun (con MASTProp) (con Bool)))
  (define evalMASTProp
    (lam m
      (case m
        (MASTTrue () (con True))
        (MASTFalse () (con False))
        (MASTNot (x) [not [evalMASTProp x]])
        (MASTAnd (x y)
          [and [evalMASTProp x] [evalMASTProp y]])
        (MASTOr (x y)
          [or [evalMASTProp x] [evalMASTProp y]]))))
  
  
  (data MASTTree ()
    (MASTSuccess)
    (MASTFailure)
    (MASTIf (con MASTProp)
            (con MASTTree)
            (con MASTTree)))
  
  
  (data MASTPath ()
    (MASTPathSuccess)
    (MASTPathFailure)
    (MASTPathIfTrue (con MASTProp)
                    (con MASTPath)
                    (bytestring))
    (MASTPathIfFalse (con MASTProp)
                     (bytestring)
                     (con MASTPath)))
  
  
  (declare evalMASTPath
    (fun (con MASTPath) (con Bool)))
  (define evalMASTPath
    (lam m
      (case m
        (MASTPathSuccess () (con True))
        (MASTPathFailure () (con False))
        (MASTPathIfTrue (test t f)
          (case [evalMASTProp test]
            (True () [evalMASTPath t])
            (False ()
              (con False))))
        (MASTPathIfFalse (test t f)
          (case [evalMASTProp test]
            (True ()
              (con False))
            (False () [evalMASTPath f]))))))
  
  
  (declare hashMASTProp
    (fun (con MASTProp) (bytestring)))
  (define hashMASTProp
    (lam m
      (case m
        (MASTTrue () #00)
        (MASTFalse () #01)
        (MASTNot (x)
          [sha2_256
            [concatenate #02 [hashMASTProp x]]])
        (MASTAnd (x y)
          [sha2_256
            [concatenate #03
              [concatenate
                [hashMASTProp x]
                [hashMASTProp y]]]])
        (MASTOr (x y)
          [sha2_256
            [concatenate #04
              [concatenate
                [hashMASTProp x]
                [hashMASTProp y]]]]))))
  
  
  (declare hashMASTTree
    (fun (con MASTTree) (bytestring)))
  (define hashMASTTree
    (lam m
      (case m
        (MASTSuccess () #00)
        (MASTFailure () #01)
        (MASTIf (test t f)
          [sha2_256
            [concatenate #02
              [concatenate
                [hashMASTTree t]
                [hashMASTTree f]]]]))))
  
  
  (declare hashMASTPath
    (fun (con MASTPath) (bytestring)))
  (define hashMASTPath
    (lam m
      (case m
        (MASTPathSuccess () #00)
        (MASTPathFailure () #01)
        (MASTPathIfTrue (test t fhash)
          [sha2_256
            [concatenate #02
              [concatenate
                [hashMASTPath t]
                fhash]]])
        (MASTPathIfFalse (test thash f)
          [sha2_256
            [concatenate #02
              [concatenate
                thash
                [hashMASTPath f]]]]))))
  
  
  (declare checkMAST
    (fun (bytestring)
         (fun (con MASTPath)
              (con Bool))))
  (define checkMAST
    (lam hash (lam path
      (case [evalMASTPath path]
        (False ()
          (con False))
        (True ()
          [equalsByteString
            hash
            [hashMASTPath path]])))))

)