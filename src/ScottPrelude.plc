(program
  (module Prelude
    (import)
    (export
      
      (unit
       pair
       bool)
       
      (id))
    
    
    
    
    
    
    
    
    
    
    
    ;;
    ;; Function Tools
    ;;
    
    (declare id (forall a (type) (fun a a)))
    (define id
      (abs a (lam x x)))
    
    
    (declare const
      (forall a (type) (forall b (type)
        (fun a (fun b a)))))
    (define const
      (abs a (abs b
        (lam x (lam y x)))))
    
    
    (declare flip
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun a (fun b c))
             (fun b (fun a c)))))))
    (define flip
      (abs a (abs b (abs c
        (lam f (lam x (lam y
          [f y x])))))))
    
    
    (declare applyTo
      (forall a (type) (forall b (type)
        (fun a (fun (fun a b) b)))))
    (define applyTo
      (abs a (abs b
        (lam x (lam f
          [f x])))))
    
    
    (declare compose
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun b c)
             (fun (fun a b)
                  (fun a c)))))))
    (define compose
      (abs a (abs b (abs c
        (lam f (lam g (lam x
          [f [g x]])))))))
    
    
    (declare compose2
      (forall a (type) (forall b (type) (forall c (type) (forall d (type)
        (fun (fun c d)
             (fun (fun a (fun b c))
                  (fun a (fun b d)))))))))
    (define compose2
      (abs a (abs b (abs c (abs d
        (lam f (lam g (lam x (lam y
          [f [g x y]])))))))))
    
    
    
    ;;
    ;; Unit Tools
    ;;
    
    ;; (data Unit () (MkUnit))
    (type unit (forall a (type) (fun a a)))
    
    
    (declare mkUnit Prelude.unit)
    (define mkUnit
      (abs a (lam x x)))
    
    
    
    ;;
    ;; Boolean Tools
    ;;
    
    ;; (data Bool () (True) (False))
    (type bool
      (forall a (type)
        (fun (fun Prelude.unit a)
          (fun (fun Prelude.unit a)
               a))))
    
    
    (declare true Prelude.bool)
    (define true
      (abs a (lam t (lam f [t Prelude.mkUnit]))))
    
    (declare false Prelude.bool)
    (define false
      (abs a (lam t (lam f [f Prelude.mkUnit]))))
    
    (declare caseBool
      (forall a (type)
        (fun Prelude.bool
          (fun (fun Prelude.unit a)
            (fun (fun Prelude.unit a)
                 a)))))
    (define caseBool
      (abs a (lam x (lam t (lam f
        [(inst x a) t f])))))
    
    
    
    
    
    
    
    
    
    (declare equalsBool
      (fun Prelude.bool
        (fun Prelude.bool
             Prelude.bool)))
    (define equalsBool (lam x (lam y
      [(inst x Prelude.bool)
        (lam u
          [(inst y Prelude.bool)
            (lam u' Prelude.true)
            (lam u' Prelude.false)])
        (lam u
          [(inst y Prelude.bool)
            (lam u' Prelude.false)
            (lam u' Prelude.true)])])))
    

    (declare not
      (fun Prelude.bool Prelude.bool))
    (define not
      (lam x
        [(inst x Prelude.bool)
          (lam u Prelude.false)
          (lam u Prelude.true)]))
    
    
    (declare and
      (fun Prelude.bool
           (fun Prelude.bool
                Prelude.bool)))
    (define and
      (lam x (lam y
        [(inst x Prelude.bool)
          (lam u y)
          (lam u Prelude.false)])))
    
    
    (declare or
      (fun Prelude.bool
           (fun Prelude.bool
                Prelude.bool)))
    (define or
      (lam x (lam y
        [(inst x Prelude.bool)
          (lam u Prelude.true)
          (lam u y)])))
    
    
    
    
    ;;
    ;; Pair Tools
    ;;
    
    (type pair
      (lam a (type) (lam b (type)
        (forall r (type)
          (fun (fun a (fun b r))
               r)))))
    
    
    (declare mkPair
      (forall a (type)
        (forall b (type)
          (fun a (fun b [Prelude.pair a b])))))
    (define mkPair
      (abs a (abs b (lam x (lam y
        (abs r (lam k [k x y])))))))
    
    
    (declare casePair
      (forall a (type)
        (forall b (type)
          (forall r (type)
            (fun [Prelude.pair a b]
              (fun (fun a (fun b r))
                   r))))))
    (define casePair
      (abs a (abs b (abs r (lam p (lam k
        [(inst p r) k]))))))
    
    
    (declare equalsPair
      (forall a (type) (forall b (type)
        (fun (fun a (fun a Prelude.bool))
          (fun (fun b (fun b Prelude.bool))
            (fun [Prelude.pair a b]
              (fun [Prelude.pair a b]
                   Prelude.bool)))))))
    (define equalsPair (abs a (abs b (lam eqA (lam eqB (lam p1 (lam p2
      [(inst p1 Prelude.bool)
        (lam x1 (lam y1
          [(inst p2 Prelude.bool)
            (lam x2 (lam y2
              [Prelude.and [eqA x1 x2] [eqB y1 y2]]))]))])))))))
    
    
    (declare fst
      (forall a (type) (forall b (type)
        (fun [Prelude.pair a b] a))))
    (define fst
      (abs a (abs b
        (lam p
          [(inst p a)
            (lam x (lam y x))]))))
    
    
    (declare snd
      (forall a (type) (forall b (type)
        (fun [Prelude.pair a b] b))))
    (define snd
      (abs a (abs b
        (lam p
          [(inst p b)
            (lam x (lam y y))]))))
    
    
    (declare curry
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun [Prelude.pair a b] c)
             (fun a (fun b c)))))))
    (define curry
      (abs a (abs b (abs c
        (lam f (lam x (lam y
          [f [(inst (inst Prelude.mkPair a) b) x y]])))))))
    
    
    (declare uncurry
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun a (fun b c))
             (fun [Prelude.pair a b] c))))))
    (define uncurry
      (abs a (abs b (abs c
        (lam f (lam p
          [(inst p c)
            (lam x (lam y [f x y]))]))))))
    
    
    (declare swap
      (forall a (type) (forall b (type)
        (fun [Prelude.pair a b]
             [Prelude.pair b a]))))
    (define swap
      (abs a (abs b
        (lam p
          [(inst p [Prelude.pair b a])
            (lam x (lam y
              [(inst (inst Prelude.mkPair b) a) y x]))]))))
    
    
    
    
    
    
    
    ;;
    ;; Integer Tools
    ;;
    
    (declare addInteger
      (fun (integer) (fun (integer) (integer))))
    (define addInteger
      (lam x (lam y
        (builtin addInteger x y))))
    
    
    (declare subtractInteger
      (fun (integer) (fun (integer) (integer))))
    (define subtractInteger
      (lam x (lam y
        (builtin subtractInteger x y))))
    
    
    (declare multiplyInteger
      (fun (integer) (fun (integer) (integer))))
    (define multiplyInteger
      (lam x (lam y
        (builtin multiplyInteger x y))))
    
    
    (declare divideInteger
      (fun (integer) (fun (integer) (integer))))
    (define divideInteger
      (lam x (lam y
        (builtin divideInteger x y))))
    
    
    (declare remainderInteger
      (fun (integer) (fun (integer) (integer))))
    (define remainderInteger
      (lam x (lam y
        (builtin remainderInteger x y))))
    
    
    (declare equalsInteger
      (fun (integer) (fun (integer) Prelude.bool)))
    (define equalsInteger
      (lam x (lam y
        (builtin equalsInteger x y))))
    
    
    (declare lessThanInteger
      (fun (integer) (fun (integer) Prelude.bool)))
    (define lessThanInteger
      (lam x (lam y
        (builtin lessThanInteger x y))))
    
    
    (declare greaterThanInteger
      (fun (integer) (fun (integer) Prelude.bool)))
    (define greaterThanInteger
      (lam x (lam y
        (builtin lessThanInteger y x))))
    
    
    (declare lessThanEqualsInteger
      (fun (integer) (fun (integer) Prelude.bool)))
    (define lessThanEqualsInteger
      (lam x (lam y
        (builtin lessThanEqualsInteger x y))))
    
    
    (declare greaterThanEqualsInteger
      (fun (integer) (fun (integer) Prelude.bool)))
    (define greaterThanEqualsInteger
      (lam x (lam y
        (builtin lessThanEqualsInteger y x))))
    
    
    (declare maxInteger
      (fun (integer) (fun (integer) (integer))))
    (define maxInteger
      (lam x (lam y
        [(inst [Prelude.lessThanInteger x y] (integer))
          (lam u y)
          (lam u x)])))
    
    
    (declare minInteger
      (fun (integer) (fun (integer) (integer))))
    (define minInteger
      (lam x (lam y
        [(inst [Prelude.lessThanInteger x y] (integer))
          (lam u x)
          (lam u y)])))
    
    
    (declare integerToFloat
      (fun (integer) (float)))
    (define integerToFloat
      (lam x
        (builtin integerToFloat x)))
    
    
    (declare integerToByteString
      (fun (integer) (bytestring)))
    (define integerToByteString
      (lam x
        (builtin integerToByteString x)))
    
    
    
    ;;
    ;; Float Tools
    ;;
    
    (declare addFloat
      (fun (float) (fun (float) (float))))
    (define addFloat
      (lam x (lam y
        (builtin addFloat x y))))
    
    
    (declare subtractFloat
      (fun (float) (fun (float) (float))))
    (define subtractFloat
      (lam x (lam y
        (builtin subtractFloat x y))))
    
    
    (declare multiplyFloat
      (fun (float) (fun (float) (float))))
    (define multiplyFloat
      (lam x (lam y
        (builtin multiplyFloat x y))))
    
    
    (declare divideFloat
      (fun (float) (fun (float) (float))))
    (define divideFloat
      (lam x (lam y
        (builtin divideFloat x y))))
    
    
    (declare equalsFloat
      (fun (float) (fun (float) Prelude.bool)))
    (define equalsFloat
      (lam x (lam y
        (builtin equalsFloat x y))))
    
    
    (declare lessThanFloat
      (fun (float) (fun (float) Prelude.bool)))
    (define lessThanFloat
      (lam x (lam y
        (builtin lessThanFloat x y))))
    
    
    (declare greaterThanFloat
      (fun (float) (fun (float) Prelude.bool)))
    (define greaterThanFloat
      (lam x (lam y
        (builtin lessThanFloat y x))))
    
    
    (declare lessThanEqualsFloat
      (fun (float) (fun (float) Prelude.bool)))
    (define lessThanEqualsFloat
      (lam x (lam y
        (builtin lessThanEqualsFloat x y))))
    
    
    (declare greaterThanEqualsFloat
      (fun (float) (fun (float) Prelude.bool)))
    (define greaterThanEqualsFloat
      (lam x (lam y
        (builtin lessThanEqualsFloat y x))))
    
    
    (declare ceil
      (fun (float) (integer)))
    (define ceil
      (lam x
        (builtin ceil x)))
    
    
    (declare floor
      (fun (float) (integer)))
    (define floor
      (lam x
        (builtin floor x)))
    
    
    (declare maxFloat
      (fun (float) (fun (float) (float))))
    (define maxFloat
      (lam x (lam y
        [(inst [Prelude.lessThanFloat x y] (float))
          (lam u y)
          (lam u x)])))
    
    
    (declare minFloat
      (fun (float) (fun (float) (float))))
    (define minFloat
      (lam x (lam y
        [(inst [Prelude.lessThanFloat x y] (float))
          (lam u x)
          (lam u y)])))
    
    
    
    ;;
    ;; ByteString Tools
    ;;
    
    (declare concatenate
      (fun (bytestring) (fun (bytestring) (bytestring))))
    (define concatenate
      (lam x (lam y
        (builtin concatenate x y))))
    
    
    (declare takeByteString
      (fun (integer) (fun (bytestring) (bytestring))))
    (define takeByteString
      (lam n (lam x
        (builtin takeByteString n x))))
    
    
    (declare dropByteString
      (fun (integer) (fun (bytestring) (bytestring))))
    (define dropByteString
      (lam n (lam x
        (builtin dropByteString n x))))
    
    
    (declare sha2_256
      (fun (bytestring) (bytestring)))
    (define sha2_256
      (lam x
        (builtin sha2_256 x)))
    
    
    (declare sha3_256
      (fun (bytestring) (bytestring)))
    (define sha3_256
      (lam x
        (builtin sha3_256 x)))
    
    
    (declare equalsByteString
      (fun (bytestring) (fun (bytestring) Prelude.bool)))
    (define equalsByteString
      (lam x (lam y
        (builtin equalsByteString x y))))
    
    
    
    ;;
    ;; Maybe Tools
    ;;
    
    ;; (data Maybe ((a (type)))
    ;;       (Nothing)
    ;;       (Just a))
    
    (type maybe
      (lam a (type)
        (forall r (type)
          (fun (fun Prelude.unit r)
            (fun (fun a r)
                 r)))))
    
    
    (declare nothing
      (forall a (type) [Prelude.maybe a]))
    (define nothing
      (abs a (abs r (lam n (lam j [n Prelude.mkUnit])))))
    
    
    (declare just
      (forall a (type)
        (fun a [Prelude.maybe a])))
    (define just
      (abs a (lam x (abs r (lam n (lam j [j x]))))))
    
    
    (declare caseMaybe
      (forall a (type)
        (forall r (type)
          (fun [Prelude.maybe a]
            (fun (fun Prelude.unit r)
              (fun (fun a r)
                   r))))))
    (define caseMaybe
      (abs a (abs r (lam m (lam n (lam j
        [(inst m r) n j]))))))
    
    
    (declare isJust
      (forall a (type)
        (fun [Prelude.maybe a] Prelude.bool)))
    (define isJust
      (abs a
        (lam m
          [(inst m Prelude.bool)
            (lam u Prelude.false)
            (lam x Prelude.true)])))
    
    
    (declare isNothing
      (forall a (type)
        (fun [Prelude.maybe a] Prelude.bool)))
    (define isNothing
      (abs a
        (lam m
          [(inst m Prelude.bool)
            (lam u Prelude.true)
            (lam x Prelude.false)])))
    
    
    (declare fromMaybe
      (forall a (type)
        (fun a (fun [Prelude.maybe a] a))))
    (define fromMaybe
      (abs a
        (lam n (lam m
          [(inst m a)
            (lam u n)
            (lam x x)]))))
    
    
    (declare mapMaybe
      (forall a (type) (forall b (type)
        (fun (fun a b)
             (fun [Prelude.maybe a]
                  [Prelude.maybe b])))))
    (define mapMaybe
      (abs a (abs b
        (lam f (lam m
          [(inst m [Prelude.maybe b])
            (lam u (inst Prelude.nothing b))
            (lam x [(inst Prelude.just b) [f x]])])))))
    
    
    (declare equalsMaybe
      (forall a (type)
        (fun (fun a (fun a Prelude.bool))
          (fun [Prelude.maybe a]
            (fun [Prelude.maybe a]
              Prelude.bool)))))
    (define equalsMaybe
      (abs a (lam eq (lam m (lam m'
        [(inst m Prelude.bool)
          (lam u
            [(inst m' Prelude.bool)
              (lam u' Prelude.true)
              (lam u Prelude.false)])
          (lam x
            [(inst m' Prelude.bool)
              (lam u Prelude.false)
              (lam y [eq x y])])])))))
    
    
    
    ;;
    ;; Either Tools
    ;;
    
    (type either
      (lam a (type)
        (lam b (type)
          (forall r (type)
            (fun (fun a r)
              (fun (fun b r)
                   r))))))
    
    
    (declare left
      (forall a (type)
        (forall b (type)
          (fun a [Prelude.either a b]))))
    (define left
      (abs a (abs b (lam x
        (abs r (lam l (lam r [l x])))))))
    
    
    (declare right
      (forall a (type)
        (forall b (type)
          (fun b [Prelude.either a b]))))
    (define right
      (abs a (abs b (lam y
        (abs r (lam l (lam r [r y])))))))
    
    
    (declare caseEither
      (forall a (type)
        (forall b (type)
          (forall c (type)
            (fun [Prelude.either a b]
              (fun (fun a c)
                (fun (fun b c)
                     c)))))))
    (define caseEither
      (abs a (abs b (abs c
        (lam d (lam l (lam r
          [(inst d c) l r])))))))
    
    
    (declare isLeft
      (forall a (type)
        (forall b (type)
          (fun [Prelude.either a b]
               Prelude.bool))))
    (define isLeft
      (abs a (abs b (lam d
        [(inst d Prelude.bool)
          (lam x Prelude.true)
          (lam y Prelude.false)]))))


    (declare isRight
      (forall a (type)
        (forall b (type)
          (fun [Prelude.either a b]
               Prelude.bool))))
    (define isRight
      (abs a (abs b (lam d
        [(inst d Prelude.bool)
          (lam x Prelude.false)
          (lam y Prelude.true)]))))
    
    
    (declare eitherToMaybe
      (forall a (type)
        (forall b (type)
          (fun [Prelude.either a b]
               [Prelude.maybe b]))))
    (define eitherToMaybe
      (abs a (abs b (lam d
        [(inst d [Prelude.maybe b])
          (lam x (inst Prelude.nothing b))
          (lam y [(inst Prelude.just b) y])]))))
    
    
    (declare maybeToEither
      (forall a (type)
        (forall b (type)
          (fun a
            (fun [Prelude.maybe b]
                 [Prelude.either a b])))))
    (define maybeToEither
      (abs a (abs b (lam x (lam m
        [(inst m [Prelude.either a b])
          (lam u [(inst (inst Prelude.left a) b) x])
          (lam y [(inst (inst Prelude.right a) b) y])])))))
    
     
    (declare equalsEither
      (forall a (type) (forall b (type)
        (fun (fun a (fun a Prelude.bool))
          (fun (fun b (fun b Prelude.bool))
            (fun [Prelude.either a b]
              (fun [Prelude.either a b]
                Prelude.bool)))))))
    (define equalsEither
      (abs a (abs b (lam eqA (lam eqB (lam d (lam d'
        [(inst d Prelude.bool)
          (lam x
            [(inst d' Prelude.bool)
              (lam x' [eqA x x'])
              (lam y' Prelude.false)])
          (lam y
            [(inst d' Prelude.bool)
              (lam x' Prelude.false)
              (lam y' [eqB y y'])])])))))))
    
    
    
    ;;
    ;; List Tools
    ;;
    
    (data ListWrapper ((a (type)))
      (MkListWrapper (forall r (type)
                       (fun (fun Prelude.unit r)
                         (fun (fun a (fun (con Prelude.ListWrapper a) r))
                              r)))))
    
    
    (type list (lam a (type) (con Prelude.ListWrapper a)))
    
    
    (declare nil
      (forall a (type)
        [Prelude.list a]))
    (define nil
      (abs a
        (con Prelude.MkListWrapper
          (abs r (lam n (lam c [n Prelude.mkUnit]))))))
    
    
    (declare cons
      (forall a (type)
        (fun a
          (fun [Prelude.list a]
               [Prelude.list a]))))
    (define cons
      (abs a (lam x (lam xs
        (con Prelude.MkListWrapper
          (abs r (lam n (lam c [c x xs]))))))))
    
    
    (declare caseList
      (forall a (type)
        (forall r (type)
          (fun [Prelude.list a]
            (fun (fun Prelude.unit r)
              (fun (fun a (fun [Prelude.list a] r))
                   r))))))
    (define caseList
      (abs a (abs r (lam xs
        (case xs
          (Prelude.MkListWrapper (k) (inst k r)))))))
    
    
    (declare equalsList
      (forall a (type)
        (fun (fun a (fun a Prelude.bool))
          (fun [Prelude.list a]
            (fun [Prelude.list a]
                 Prelude.bool)))))
    (define equalsList
      (abs a (lam eqA (lam xs (lam xs'
        (case xs (Prelude.MkListWrapper (xscase)
          (case xs' (Prelude.MkListWrapper (xscase')
            [(inst xscase Prelude.bool)
              (lam u
                [(inst xscase' Prelude.bool)
                  (lam u' Prelude.true)
                  (lam y (lam ys Prelude.false))])
              (lam y (lam ys
                (case ys (Prelude.MkListWrapper (yscase)
                  [(inst yscase Prelude.bool)
                    (lam u' Prelude.false)
                    (lam z (lam zs
                      [Prelude.and
                        [eqA y z]
                        [(inst Prelude.equalsList a) eqA ys zs]]))]))))])))))))))
    
    
    (declare append
      (forall a (type)
        (fun [Prelude.list a]
          (fun [Prelude.list a]
               [Prelude.list a]))))
    (define append
      (abs a (lam xs (lam ys
        (case xs (Prelude.MkListWrapper (xscase)
          [(inst xscase [Prelude.list a])
            (lam u ys)
            (lam x (lam xs
              [(inst Prelude.cons a) x
                [(inst Prelude.append a) xs ys]]))]))))))
    
    
    (declare head
      (forall a (type)
        (fun [Prelude.list a]
             [Prelude.maybe a])))
    (define head
      (abs a (lam xs
        (case xs (Prelude.MkListWrapper (xscase)
          [(inst xscase [Prelude.maybe a])
            (lam u (inst Prelude.nothing a))
            (lam x (lam xs [(inst Prelude.just a) x]))])))))
    
    
    (declare last
      (forall a (type)
        (fun [Prelude.list a]
             [Prelude.maybe a])))
    (define last
      (abs a (lam xs
        (case xs (Prelude.MkListWrapper (xscase)
          [(inst xscase [Prelude.maybe a])
            (lam u (inst Prelude.nothing a))
            (lam x (lam xs'
              (case xs' (Prelude.MkListWrapper (xscase')
                [(inst xscase' [Prelude.maybe a])
                  (lam u' [(inst Prelude.just a) x])
                  (lam x' (lam xs''
                    [(inst Prelude.last a) xs']))]))))])))))
    
    
    (declare tail
      (forall a (type)
        (fun [Prelude.list a]
             [Prelude.maybe [Prelude.list a]])))
    (define tail
      (abs a (lam xs (case xs (Prelude.MkListWrapper (xscase)
        [(inst xscase [Prelude.maybe [Prelude.list a]])
          (lam u (inst Prelude.nothing [Prelude.list a]))
          (lam x (lam xs'
            [(inst Prelude.just [Prelude.list a]) xs']))])))))
    
    
    (declare init
      (forall a (type)
        (fun [Prelude.list a]
             [Prelude.maybe [Prelude.list a]])))
    (define init
      (abs a (lam xs (case xs (Prelude.MkListWrapper (xscase)
        [(inst xscase [Prelude.maybe [Prelude.list a]])
          (lam u (inst Prelude.nothing [Prelude.list a]))
          (lam x (lam xs'
            [(inst [(inst Prelude.init a) xs'] [Prelude.maybe [Prelude.list a]])
              (lam u' [(inst Prelude.just [Prelude.list a])
                        [(inst Prelude.cons a)
                          x
                          (inst Prelude.nil a)]])
              (lam ys [(inst Prelude.just [Prelude.list a])
                        [(inst Prelude.cons a) x ys]])]))])))))
    
    
    (declare uncons
      (forall a (type)
        (fun [Prelude.list a]
             [Prelude.maybe [Prelude.pair a [Prelude.list a]]])))
    (define uncons
      (abs a (lam xs (case xs (Prelude.MkListWrapper (xscase)
        [(inst xscase [Prelude.maybe [Prelude.pair a [Prelude.list a]]])
          (lam u (inst Prelude.nothing [Prelude.pair a [Prelude.list a]]))
          (lam x (lam xs'
            [(inst Prelude.just [Prelude.pair a [Prelude.list a]])
              [(inst (inst Prelude.mkPair a) [Prelude.list a])
                x
                xs']]))])))))
    
    
    (declare null
      (forall a (type)
        (fun [Prelude.list a]
             Prelude.bool)))
    (define null
      (abs a (lam xs (case xs (Prelude.MkListWrapper (xscase)
        [(inst xscase Prelude.bool)
          (lam u Prelude.true)
          (lam x (lam xs' Prelude.false))])))))
    
    
    (declare length
      (forall a (type)
        (fun [Prelude.list a]
             (integer))))
    (define length
      (abs a (lam xs (case xs (Prelude.MkListWrapper (xscase)
        [(inst xscase (integer))
          (lam u 0)
          (lam x (lam xs'
            [Prelude.addInteger 1 [(inst Prelude.length a) xs']]))])))))
    
    
    (declare elem
      (forall a (type)
        (fun (fun a (fun a Prelude.bool))
          (fun a
            (fun [Prelude.list a]
                 Prelude.bool)))))
    (define elem
      (abs a (lam eqA (lam y (lam xs (case xs (Prelude.MkListWrapper (xscase)
        [(inst xscase Prelude.bool)
          (lam u Prelude.false)
          (lam x (lam xs'
            [(inst [eqA x y] Prelude.bool)
              (lam u' Prelude.true)
              (lam u' [(inst Prelude.elem a) eqA y xs'])]))])))))))
    
    
    (declare take
      (forall a (type)
        (fun (integer)
          (fun [Prelude.list a]
               [Prelude.list a]))))
    (define take
      (abs a (lam n (lam xs (case xs (Prelude.MkListWrapper (xscase)
        [(inst [Prelude.equalsInteger 0 n] [Prelude.list a])
          (lam u (inst Prelude.nil a))
          (lam u [(inst xscase [Prelude.list a])
            (lam u' (inst Prelude.nil a))
            (lam x (lam xs'
              [(inst Prelude.cons a)
                x
                [(inst Prelude.take a)
                  [Prelude.subtractInteger n 1]
                  xs']]))])]))))))
    
    
    (declare drop
      (forall a (type)
        (fun (integer)
          (fun [Prelude.list a]
               [Prelude.list a]))))
    (define drop
      (abs a (lam n (lam xs (case xs (Prelude.MkListWrapper (xscase)
        [(inst [Prelude.equalsInteger n 0] [Prelude.list a])
          (lam u (inst Prelude.nil a))
          (lam u
            [(inst xscase [Prelude.list a])
              (lam u' (inst Prelude.nil a))
              (lam x (lam xs'
                [(inst Prelude.drop a)
                  [Prelude.subtractInteger n 1]
                  xs']))])]))))))
    
    
    (declare splitAt
      (forall a (type)
        (fun (integer)
          (fun [Prelude.list a]
               [Prelude.pair [Prelude.list a] [Prelude.list a]]))))
    (define splitAt
      (abs a (lam n (lam xs (case xs (Prelude.MkListWrapper (xscase)
        [(inst [Prelude.equalsInteger n 0] [Prelude.pair [Prelude.list a] [Prelude.list a]])
          (lam u
            [(inst (inst Prelude.mkPair [Prelude.list a]) [Prelude.list a])
              (inst Prelude.nil a)
              xs])
          (lam u
            [(inst xscase [Prelude.pair [Prelude.list a] [Prelude.list a]])
              (lam u'
                [(inst (inst Prelude.mkPair [Prelude.list a]) [Prelude.list a])
                  (inst Prelude.nil a)
                  (inst Prelude.nil a)])
              (lam x (lam xs'
                [(inst [(inst Prelude.splitAt a) [Prelude.subtractInteger n 1] xs'] [Prelude.pair [Prelude.list a] [Prelude.list a]])
                  (lam ls (lam rs
                    [(inst (inst Prelude.mkPair [Prelude.list a]) [Prelude.list a])
                      [(inst Prelude.cons a) x ls]
                      rs]))]))])]))))))
                
    
    (declare takeWhile
      (forall a (type)
        (fun (fun a Prelude.bool)
          (fun [Prelude.list a]
               [Prelude.list a]))))
    (define takeWhile
      (abs a (lam p (lam xs (case xs (Prelude.MkListWrapper (xscase)
        [(inst xscase [Prelude.list a])
          (lam u (inst Prelude.nil a))
          (lam x (lam xs'
            [(inst [p x] [Prelude.list a])
              (lam u
                [(inst Prelude.cons a)
                  x
                  [(inst Prelude.takeWhile a)
                    p
                    xs']])
              (lam u
                (inst Prelude.nil a))]))]))))))
    
    
    (declare dropWhile
      (forall a (type)
        (fun (fun a Prelude.bool)
          (fun [Prelude.list a]
               [Prelude.list a]))))
    (define dropWhile
      (abs a (lam p (lam xs (case xs (Prelude.MkListWrapper (xscase)
        [(inst xscase [Prelude.list a])
          (lam u (inst Prelude.nil a))
          (lam x (lam xs'
            [(inst [p x] [Prelude.list a])
              (lam u
                [(inst Prelude.dropWhile a)
                  p
                  xs'])
              (lam u xs)]))]))))))
    
                  
    ;-
    (declare span
      (forall a (type)
        (fun (fun a Prelude.bool)
             (fun [Prelude.list a]
                  (con Prelude.Pair
                    [Prelude.list a]
                    [Prelude.list a])))))
    (define span
      (abs a
        (lam p (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.MkPair
                   (con Prelude.Nil)
                   (con Prelude.Nil)))
            (Prelude.Cons (x xs')
              (case [p x]
                (Prelude.True ()
                  (case [(inst Prelude.span a) p xs']
                    (Prelude.MkPair (ys zs)
                      (con Prelude.MkPair
                           (con Prelude.Cons x ys)
                           zs))))
                (Prelude.False ()
                  (con Prelude.MkPair
                       (con Prelude.Nil)
                       (con Prelude.Cons x xs'))))))))))
    
    
    (declare groupBy
      (forall a (type)
        (fun (fun a (fun a Prelude.bool))
             (fun [Prelude.list a]
                  (con Prelude.List [Prelude.list a])))))
    (define groupBy
      (abs a
        (lam eq (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.Nil))
            (Prelude.Cons (x xs')
              (case [(inst Prelude.span a) [eq x] xs']
                (Prelude.MkPair
                  (ys zs)
                  (con Prelude.Cons
                       (con Prelude.Cons x ys)
                       [(inst Prelude.groupBy a) eq zs])))))))))
    
    
    (declare foldr
      (forall a (type) (forall b (type)
        (fun (fun a (fun b b))
             (fun b
                  (fun [Prelude.list a]
                       b))))))
    (define foldr
      (abs a (abs b
        (lam c (lam n (lam xs
          (case xs
            (Prelude.Nil () n)
            (Prelude.Cons (x xs')
              [c x [(inst (inst Prelude.foldr a) b) c n xs']]))))))))
    -;
    
    (declare foldl
      (forall a (type) (forall b (type)
        (fun (fun b (fun a b))
             (fun b
                  (fun [Prelude.list a]
                       b))))))
    (define foldl
      (abs a (abs b
        (lam s (lam n (lam xs (case xs (Prelude.MkListWrapper (xscase)
          [(inst xscase b)
            (lam u n)
            (lam x (lam xs'
              [(inst (inst Prelude.foldl a) b) s [s n x] xs']))]))))))))
    
    ;-
    (declare unfoldr
      (forall a (type) (forall b (type)
        (fun (fun b (con Prelude.Maybe (con Prelude.Pair a b)))
             (fun b [Prelude.list a])))))
    (define unfoldr
      (abs a (abs b
        (lam step (lam s
          (case [step s]
            (Prelude.Nothing ()
              (con Prelude.Nil))
            (Prelude.Just (p)
              (case p
                (Prelude.MkPair (x s')
                  (con Prelude.Cons
                       x
                       [(inst (inst Prelude.unfoldr a) b) step s']))))))))))
    
    
    (declare replicate
      (forall a (type)
        (fun (integer) (fun a [Prelude.list a]))))
    (define replicate
      (abs a
        (lam n (lam x
          (case [Prelude.equalsInteger n 0]
            (Prelude.True ()
              (con Prelude.Nil))
            (Prelude.False ()
              (con Prelude.Cons
                   x
                   [(inst Prelude.replicate a)
                     [Prelude.subtractInteger n 1]
                     x])))))))
    -;
    
    
    (declare map
      (forall a (type)
        (forall b (type)
          (fun (fun a b)
            (fun [Prelude.list a]
                 [Prelude.list b])))))
    (define map
      (abs a (abs b (lam f (lam xs (case xs (Prelude.MkListWrapper (xscase)
        [(inst xscase [Prelude.list b])
          (lam u (inst Prelude.nil b))
          (lam x (lam xs'
            [(inst Prelude.cons b)
              [f x]
              [(inst (inst Prelude.map a) b) f xs']]))])))))))
    
    
    (declare reverseOnto
      (forall a (type)
        (fun [Prelude.list a]
          (fun [Prelude.list a]
               [Prelude.list a]))))
    (define reverseOnto
      (abs a (lam xs (lam ys (case xs (Prelude.MkListWrapper (xscase)
        [(inst xscase [Prelude.list a])
          (lam u ys)
          (lam x (lam xs'
            [(inst Prelude.reverseOnto a)
              xs'
              [(inst Prelude.cons a)
                x
                ys]]))]))))))
    
    
    (declare reverse
      (forall a (type)
        (fun [Prelude.list a]
             [Prelude.list a])))
    (define reverse
      (abs a (lam xs
        [(inst Prelude.reverseOnto a)
          xs
          (inst Prelude.nil a)])))
    
    ;-
    (declare prependToAll
      (forall a (type)
        (fun a
             (fun [Prelude.list a]
                  [Prelude.list a]))))
    (define prependToAll
      (abs a
        (lam sep (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.Cons sep (con Prelude.Nil)))
            (Prelude.Cons (x xs')
              (con Prelude.Cons
                   sep
                   (con Prelude.Cons
                        x
                        [(inst Prelude.prependToAll a) sep xs']))))))))
    
    
    (declare intersperse
      (forall a (type)
        (fun a
             (fun [Prelude.list a]
                  [Prelude.list a]))))
    (define intersperse
      (abs a
        (lam sep (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.Nil))
            (Prelude.Cons (x xs')
              (con Prelude.Cons
                   x
                   [(inst Prelude.prependToAll a) sep xs'])))))))
    
    
    (declare concat
      (forall a (type)
        (fun (con Prelude.List [Prelude.list a])
             [Prelude.list a])))
    (define concat
      (abs a
        (lam xss
          (case xss
            (Prelude.Nil ()
              (con Prelude.Nil))
            (Prelude.Cons (xs xss')
              [(inst Prelude.append a) xs [(inst Prelude.concat a) xss']])))))
    
    
    (declare concatMap
      (forall a (type) (forall b (type)
        (fun (fun a [Prelude.list b])
             (fun [Prelude.list a]
                  [Prelude.list b])))))
    (define concatMap
      (abs a (abs b
        (lam f (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.Nil))
            (Prelude.Cons (x xs')
              [(inst Prelude.append b) [f x] [(inst (inst Prelude.concatMap a) b) f xs']])))))))
    
    
    (declare intercalate
      (forall a (type)
        (fun [Prelude.list a]
             (fun (con Prelude.List [Prelude.list a])
                  [Prelude.list a]))))
    (define intercalate
      (abs a
        (lam xs (lam xss
          [(inst Prelude.concat a)
            [(inst Prelude.intersperse [Prelude.list a])
              xs
              xss]]))))
    
    -;
    
    
    (declare filter
      (forall a (type)
        (fun (fun a Prelude.bool)
          (fun [Prelude.list a]
               [Prelude.list a]))))
    (define filter
      (abs a (lam p (lam xs (case xs (Prelude.MkListWrapper (xscase)
        [(inst xscase [Prelude.list a])
          (lam u (inst Prelude.nil a))
          (lam x (lam xs'
            [(inst [p x] [Prelude.list a])
              (lam u
                [(inst Prelude.cons a)
                  x
                  [(inst Prelude.filter a) p xs']])
              (lam u [(inst Prelude.filter a) p xs'])]))]))))))
    
    
    ;-
    (declare filter
      (forall a (type)
        (fun (fun a Prelude.bool)
             (fun [Prelude.list a]
                  [Prelude.list a]))))
    (define filter
      (abs a
        (lam p (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.Nil))
            (Prelude.Cons (x xs')
              (case [p x]
                (Prelude.True ()
                  (con Prelude.Cons x [(inst Prelude.filter a) p xs']))
                (Prelude.False () [(inst Prelude.filter a) p xs']))))))))
    
    
    (declare find
      (forall a (type)
        (fun (fun a Prelude.bool)
             (fun [Prelude.list a]
                  (con Prelude.Maybe a)))))
    (define find
      (abs a
        (lam p (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.Nothing))
            (Prelude.Cons (x xs')
              (case [p x]
                (Prelude.True ()
                  (con Prelude.Just x))
                (Prelude.False () [(inst Prelude.find a) p xs']))))))))
    
    
    (declare partition
      (forall a (type)
        (fun (fun a Prelude.bool)
             (fun [Prelude.list a]
                  (con Prelude.Pair
                       [Prelude.list a]
                       [Prelude.list a])))))
    (define partition
      (abs a
        (lam p (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.MkPair (con Prelude.Nil) (con Prelude.Nil)))
            (Prelude.Cons (x xs')
              (case [(inst Prelude.partition a) p xs']
                (Prelude.MkPair (ts fs)
                  (case [p x]
                    (Prelude.True ()
                      (con Prelude.MkPair (con Prelude.Cons x ts) fs))
                    (Prelude.False ()
                      (con Prelude.MkPair ts (con Prelude.Cons x fs))))))))))))
    
    
    (declare nubBy
      (forall a (type)
        (fun (fun a (fun a Prelude.bool))
             (fun [Prelude.list a]
                  [Prelude.list a]))))
    (define nubBy
      (abs a
        (lam comp (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.Nil))
            (Prelude.Cons (x xs')
              (con Prelude.Cons
                   x
                   [(inst Prelude.filter a)
                     (lam y [Prelude.not [comp x y]])
                     [(inst Prelude.nubBy a) comp xs']])))))))
    
    -;
    
    
    (declare zip
      (forall a (type)
        (forall b (type)
          (fun [Prelude.list a]
            (fun [Prelude.list b]
                 [Prelude.list [Prelude.pair a b]])))))
    (define zip
      (abs a (abs b (lam xs (lam ys (case xs (Prelude.MkListWrapper (xscase)
        [(inst xscase [Prelude.list [Prelude.pair a b]])
          (lam u (inst Prelude.nil [Prelude.pair a b]))
          (lam x (lam xs' (case ys (Prelude.MkListWrapper (yscase)
            [(inst yscase [Prelude.list [Prelude.pair a b]])
              (lam u' (inst Prelude.nil [Prelude.pair a b]))
              (lam y (lam ys'
                [(inst Prelude.cons [Prelude.pair a b])
                  [(inst (inst Prelude.mkPair a) b) x y]
                  [(inst (inst Prelude.zip a) b) xs' ys']]))]))))])))))))
    
    
    ;-
    (declare zipWith
      (forall a (type) (forall b (type) (forall c (type)
        (fun (fun a (fun b c))
             (fun [Prelude.list a]
                  (fun [Prelude.list b]
                       (con Prelude.List c))))))))
    (define zipWith
      (abs a (abs b (abs c
        (lam f (lam xs (lam ys
          (case xs
            (Prelude.Nil ()
              (con Prelude.Nil))
            (Prelude.Cons (x xs')
              (case ys
                (Prelude.Nil ()
                  (con Prelude.Nil))
                (Prelude.Cons (y ys')
                  (con Prelude.Cons
                       [f x y]
                       [(inst (inst (inst Prelude.zipWith a) b) c)
                         f xs' ys']))))))))))))
    
    
    (declare zip
      (forall a (type) (forall b (type)
        (fun [Prelude.list a]
             (fun [Prelude.list b]
                  (con Prelude.List (con Prelude.Pair a b)))))))
    (define zip
      (abs a (abs b
        (lam xs (lam ys
          [(inst (inst (inst Prelude.zipWith a) b) (con Prelude.Pair a b)) (lam x (lam y (con Prelude.MkPair x y))) xs ys])))))
    
    -;
    
    
    
    (declare unzip
      (forall a (type)
        (forall b (type)
          (fun [Prelude.list [Prelude.pair a b]]
               [Prelude.pair [Prelude.list a] [Prelude.list b]]))))
    (define unzip
      (abs a (abs b (lam ps (case ps (Prelude.MkListWrapper (pscase)
        [(inst pscase [Prelude.pair [Prelude.list a] [Prelude.list b]])
          (lam u
            [(inst (inst Prelude.mkPair [Prelude.list a]) [Prelude.list b])
              (inst Prelude.nil a)
              (inst Prelude.nil b)])
          (lam p (lam ps'
            [(inst p [Prelude.pair [Prelude.list a] [Prelude.list b]])
              (lam x (lam y
                [(inst [(inst (inst Prelude.unzip a) b) ps'] [Prelude.pair [Prelude.list a] [Prelude.list b]])
                  (lam xs (lam ys
                    [(inst (inst Prelude.mkPair [Prelude.list a]) [Prelude.list b])
                      [(inst Prelude.cons a) x xs]
                      [(inst Prelude.cons b) y ys]]))]))]))]))))))
                  
                  
    
    
    
    ;-
    (declare unzip
      (forall a (type) (forall b (type)
        (fun (con Prelude.List (con Prelude.Pair a b))
             (con Prelude.Pair [Prelude.list a]
                               [Prelude.list b])))))
    (define unzip
      (abs a (abs b
        (lam xys
          (case xys
            (Prelude.Nil ()
              (con Prelude.MkPair (con Prelude.Nil) (con Prelude.Nil)))
            (Prelude.Cons (xy xys')
              (case xy
                (Prelude.MkPair (x y)
                  (case [(inst (inst Prelude.unzip a) b) xys']
                    (Prelude.MkPair (xs ys)
                      (con Prelude.MkPair
                           (con Prelude.Cons x xs)
                           (con Prelude.Cons y ys))))))))))))
    
    
    (declare andList
      (fun (con Prelude.List Prelude.bool) Prelude.bool))
    (define andList
      (lam bs
        [(inst (inst Prelude.foldl Prelude.bool) Prelude.bool)
          Prelude.and
          Prelude.true
          bs]))
    
    
    (declare orList
      (fun (con Prelude.List Prelude.bool) Prelude.bool))
    (define orList
      (lam bs
        [(inst (inst Prelude.foldl Prelude.bool) Prelude.bool)
          Prelude.or
          Prelude.false
          bs]))
    
    
    (declare any
      (forall a (type)
        (fun (fun a Prelude.bool)
             (fun [Prelude.list a]
                  Prelude.bool))))
    (define any
      (abs a
        (lam p (lam xs [Prelude.orList [(inst (inst Prelude.map a) Prelude.bool) p xs]]))))
    
    
    (declare all
      (forall a (type)
        (fun (fun a Prelude.bool)
             (fun [Prelude.list a]
                  Prelude.bool))))
    (define all
      (abs a
        (lam p (lam xs [Prelude.andList [(inst (inst Prelude.map a) Prelude.bool) p xs]]))))
    
    -;
    
    
    
    
    (declare sumInteger
      (fun [Prelude.list (integer)] (integer)))
    (define sumInteger
      (lam xs
        [(inst (inst Prelude.foldl (integer)) (integer))
          Prelude.addInteger 0 xs]))
    
    
    
    ;-
    (declare sumFloat
      (fun (con Prelude.List (float)) (float)))
    (define sumFloat
      (lam xs [(inst (inst Prelude.foldl (float)) (float))
        Prelude.addFloat 0.0 xs]))
    
    (declare productInteger
      (fun (con Prelude.List (integer)) (integer)))
    (define productInteger
      (lam xs
        [(inst (inst Prelude.foldl (integer)) (integer))
          Prelude.multiplyInteger 1 xs]))
    
    
    (declare productFloat
      (fun (con Prelude.List (float)) (float)))
    (define productFloat
      (lam xs
        [(inst (inst Prelude.foldl (float)) (float))
          Prelude.multiplyFloat 1.0 xs]))
    
    (declare maximumBy
      (forall a (type)
        (fun (fun a (fun a Prelude.bool))
             (fun a
                  (fun [Prelude.list a]
                       a)))))
    (define maximumBy
      (abs a
        (lam comp (lam m
          [(inst (inst Prelude.foldl a) a)
            (lam x (lam y
              (case [comp x y]
                (Prelude.True () y)
                (Prelude.False () x))))
            m]))))
    
    
    (declare minimumBy
      (forall a (type)
        (fun (fun a (fun a Prelude.bool))
             (fun a
                  (fun [Prelude.list a]
                       a)))))
    (define minimumBy
      (abs a
        (lam comp (lam m
          [(inst (inst Prelude.foldl a) a)
            (lam x (lam y
              (case [comp x y]
                (Prelude.True () x)
                (Prelude.False () y))))
            m]))))
    
    
    (declare project
      (forall a (type)
        (fun [Prelude.list a]
             (fun (integer)
                  (con Prelude.Maybe a)))))
    (define project
      (abs a
        (lam xs (lam n
          (case xs
            (Prelude.Nil ()
              (con Prelude.Nothing))
            (Prelude.Cons (x xs')
              (case [Prelude.equalsInteger n 0]
                (Prelude.True ()
                  (con Prelude.Just x))
                (Prelude.False ()
                  [(inst Prelude.project a)
                    xs'
                    [Prelude.subtractInteger n 1]]))))))))
    
    
    (declare findIndex
      (forall a (type)
        (fun (fun a Prelude.bool)
             (fun [Prelude.list a]
                  (con Prelude.Maybe (integer))))))
    (define findIndex
      (abs a
        (lam p (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.Nothing))
            (Prelude.Cons (x xs')
              (case [p x]
                (Prelude.True ()
                  (con Prelude.Just 0))
                (Prelude.False ()
                  (case [(inst Prelude.findIndex a) p xs']
                    (Prelude.Nothing ()
                      (con Prelude.Nothing))
                    (Prelude.Just (i)
                      (con Prelude.Just [Prelude.addInteger i 1])))))))))))
    
    
    (declare findIndicesFrom
      (forall a (type)
        (fun (integer)
             (fun (fun a Prelude.bool)
                  (fun [Prelude.list a]
                       (con Prelude.List (integer)))))))
    (define findIndicesFrom
      (abs a
        (lam i (lam p (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.Nil))
            (Prelude.Cons (x xs')
              (case [p x]
                (Prelude.True ()
                  (con Prelude.Cons
                       i
                       [(inst Prelude.findIndicesFrom a)
                         [Prelude.addInteger i 1]
                         p
                         xs]))
                (Prelude.False ()
                  [(inst Prelude.findIndicesFrom a)
                    [Prelude.addInteger i 1]
                    p
                    xs])))))))))
    
    
    (declare findIndices
      (forall a (type)
        (fun [Prelude.list a]
             (fun (fun a Prelude.bool)
                  (con Prelude.List (integer))))))
    (define findIndices
      (abs a
        (lam xs (lam p [(inst Prelude.findIndicesFrom a) 0 p xs]))))
    
    
    (declare evenOddSplitFrom
      (forall a (type)
        (fun Prelude.bool
             (fun [Prelude.list a]
                  (con Prelude.Pair
                       [Prelude.list a]
                       [Prelude.list a])))))
    (define evenOddSplitFrom
      (abs a
        (lam b (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.MkPair (con Prelude.Nil) (con Prelude.Nil)))
            (Prelude.Cons (x xs')
              (case [(inst Prelude.evenOddSplitFrom a) [Prelude.not b] xs']
                (Prelude.MkPair (es os)
                  (case b
                    (Prelude.True ()
                      (con Prelude.MkPair (con Prelude.Cons x es) os))
                    (Prelude.False ()
                      (con Prelude.MkPair es (con Prelude.Cons x os))))))))))))
    
    
    (declare evenOddSplit
      (forall a (type)
        (fun [Prelude.list a]
             (con Prelude.Pair
                  [Prelude.list a]
                  [Prelude.list a]))))
    (define evenOddSplit
      (abs a
        (lam xs [(inst Prelude.evenOddSplitFrom a) Prelude.true xs])))
    
    
    (declare mergeBy
      (forall a (type)
        (fun (fun a (fun a Prelude.bool))
             (fun [Prelude.list a]
                  (fun [Prelude.list a]
                       [Prelude.list a])))))
    (define mergeBy
      (abs a
        (lam comp (lam xs (lam ys
          (case xs
            (Prelude.Nil () ys)
            (Prelude.Cons (x xs')
              (case ys
                (Prelude.Nil ()
                  (con Prelude.Cons x xs'))
                (Prelude.Cons (y ys')
                  (case [comp x y]
                    (Prelude.True ()
                      (con Prelude.Cons
                           x
                           [(inst Prelude.mergeBy a)
                             comp
                             xs'
                             (con Prelude.Cons y ys')]))
                    (Prelude.False ()
                      (con Prelude.Cons
                           y
                           [(inst Prelude.mergeBy a)
                             comp
                             (con Prelude.Cons x xs')
                             ys']))))))))))))
    
    
    (declare mergeSortBy
      (forall a (type)
        (fun (fun a (fun a Prelude.bool))
             (fun [Prelude.list a]
                  [Prelude.list a]))))
    (define mergeSortBy
      (abs a
        (lam comp (lam xs
          (case [(inst Prelude.evenOddSplit a) xs]
            (Prelude.MkPair (es os)
              [(inst Prelude.mergeBy a)
                comp
                [(inst Prelude.mergeSortBy a) comp es]
                [(inst Prelude.mergeSortBy a) comp os]]))))))
    
    
    (declare quickSortBy
      (forall a (type)
        (fun (fun a (fun a Prelude.bool))
             (fun [Prelude.list a]
                  [Prelude.list a]))))
    (define quickSortBy
      (abs a
        (lam comp (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.Nil))
            (Prelude.Cons (x xs')
              (case [(inst Prelude.partition a) [comp x] xs']
                (Prelude.MkPair (lo hi)
                  [(inst Prelude.append a)
                    [(inst Prelude.quickSortBy a) comp lo]
                    (con Prelude.Cons x [(inst Prelude.quickSortBy a) comp hi])]))))))))

    
    (declare listToMaybe
      (forall a (type)
        (fun [Prelude.list a] (con Prelude.Maybe a))))
    (define listToMaybe
      (abs a
        (lam xs
          (case xs
            (Prelude.Nil ()
              (con Prelude.Nothing))
            (Prelude.Cons (x xs')
              (con Prelude.Just x))))))
    
    
    (declare maybeToList
      (forall a (type)
        (fun (con Prelude.Maybe a) [Prelude.list a])))
    (define maybeToList
      (abs a
        (lam m
          (case m
            (Prelude.Nothing ()
              (con Prelude.Nil))
            (Prelude.Just (x)
              (con Prelude.Cons x (con Prelude.Nil)))))))
    
    
    (declare catMaybes
      (forall a (type)
        (fun (con Prelude.List (con Prelude.Maybe a))
             [Prelude.list a])))
    (define catMaybes
      (abs a
        (lam ms
          (case ms
            (Prelude.Nil ()
              (con Prelude.Nil))
            (Prelude.Cons (m ms')
              (case m
                (Prelude.Nothing () [(inst Prelude.catMaybes a) ms'])
                (Prelude.Just (x)
                  (con Prelude.Cons x [(inst Prelude.catMaybes a) ms']))))))))
    
    
    (declare lefts
      (forall a (type) (forall b (type)
        (fun (con Prelude.List (con Prelude.Either a b))
             [Prelude.list a]))))
    (define lefts
      (abs a (abs b
        (lam es
          (case es
            (Prelude.Nil ()
              (con Prelude.Nil))
            (Prelude.Cons (e es')
              (case e
                (Prelude.Left (x)
                  (con Prelude.Cons x [(inst (inst Prelude.lefts a) b) es']))
                (Prelude.Right (y) [(inst (inst Prelude.lefts a) b) es']))))))))
    
    
    (declare rights
      (forall a (type) (forall b (type)
        (fun (con Prelude.List (con Prelude.Either a b))
             [Prelude.list b]))))
    (define rights
      (abs a (abs b
        (lam es
          (case es
            (Prelude.Nil ()
              (con Prelude.Nil))
            (Prelude.Cons (e es')
              (case e
                (Prelude.Left (x) [(inst (inst Prelude.rights a) b) es'])
                (Prelude.Right (y)
                  (con Prelude.Cons y [(inst (inst Prelude.rights a) b) es'])))))))))
    
    
    (declare partitionEithers
      (forall a (type) (forall b (type)
        (fun (con Prelude.List (con Prelude.Either a b))
             (con Prelude.Pair
                  [Prelude.list a]
                  [Prelude.list b])))))
    (define partitionEithers
      (abs a (abs b
        (lam es
          (case es
            (Prelude.Nil ()
              (con Prelude.MkPair (con Prelude.Nil) (con Prelude.Nil)))
            (Prelude.Cons (e es')
              (case [(inst (inst Prelude.partitionEithers a) b) es']
                (Prelude.MkPair (ls rs)
                  (case e
                    (Prelude.Left (x)
                      (con Prelude.MkPair (con Prelude.Cons x ls) rs))
                    (Prelude.Right (y)
                      (con Prelude.MkPair ls (con Prelude.Cons y rs))))))))))))
    
    
    
    ;;
    ;; Blockchain Tools
    ;;
    
    
    ;; (declare verifySignature
    ;;   (fun (bytestring)
    ;;     (fun (bytestring)
    ;;       (fun (bytestring)
    ;;            Prelude.bool))))
    ;; (define verifySignature
    ;;   (lam k (lam dat (lam s
    ;;     (builtin verifySignature k dat s)))))
    ;; 
    ;; 
    ;; (declare verify
    ;;   (fun (bytestring)
    ;;        (fun (bytestring)
    ;;             (fun (con Prelude.Maybe (bytestring))
    ;;                  Prelude.bool))))
    ;; (define verify
    ;;   (lam dat (lam k (lam m
    ;;     (case m
    ;;       (cl Prelude.Nil () Prelude.false)
    ;;       (cl Prelude.Just (s) [verifySignature k dat s]))))))
    ;; 
    ;; 
    ;; (declare verifyMultiSig
    ;;   (fun (integer)
    ;;     (fun (con Prelude.List (bytestring))
    ;;       (fun (bytestring)
    ;;         (fun (con Prelude.List (con Prelude.Maybe (bytestring)))
    ;;           (comp (con Prelude.Unit)))))))
    ;; (define verifyMultiSig
    ;;   (lam n (lam keys (lam dat (lam sigs
    ;;     (case [Prelude.and
    ;;             [equalsInt
    ;;               [(inst Prelude.length (con Prelude.List (bytestring))) keys]
    ;;               [(inst Prelude.length (con Prelude.List (con Prelude.Maybe (bytestring)))) sigs]]
    ;;             [Prelude.lessThanEqualsInt
    ;;               n
    ;;               [(inst Prelude.length Prelude.bool)
    ;;                 [(inst Prelude.filter Prelude.bool) (inst id Prelude.Bool)
    ;;                   [(inst (inst (inst Prelude.zipWith (bytestring)) (con Prelude.Maybe (bytestring))) Prelude.bool)
    ;;                     [Prelude.verify dat]
    ;;                     keys
    ;;                     sigs]]]]]
    ;;       (Prelude.True () (success (con Prelude.MkUnit)))
    ;;       (Prelude.False () (failure))))))))
    
    
    (data MASTProp ()
      (MASTTrue)
      (MASTFalse)
      (MASTNot (con Prelude.MASTProp))
      (MASTAnd (con Prelude.MASTProp) (con Prelude.MASTProp))
      (MASTOr (con Prelude.MASTProp) (con Prelude.MASTProp)))
    
    
    (declare evalMASTProp
      (fun (con Prelude.MASTProp) Prelude.bool))
    (define evalMASTProp
      (lam m
        (case m
          (Prelude.MASTTrue () Prelude.true)
          (Prelude.MASTFalse () Prelude.false)
          (Prelude.MASTNot (x) [Prelude.not [Prelude.evalMASTProp x]])
          (Prelude.MASTAnd (x y)
            [Prelude.and [Prelude.evalMASTProp x] [Prelude.evalMASTProp y]])
          (Prelude.MASTOr (x y)
            [Prelude.or [Prelude.evalMASTProp x] [Prelude.evalMASTProp y]]))))
    
    
    (data MASTTree ()
      (MASTSuccess)
      (MASTFailure)
      (MASTIf (con Prelude.MASTProp)
              (con Prelude.MASTTree)
              (con Prelude.MASTTree)))
    
    
    (data MASTPath ()
      (MASTPathSuccess)
      (MASTPathFailure)
      (MASTPathIfTrue (con Prelude.MASTProp)
                      (con Prelude.MASTPath)
                      (bytestring))
      (MASTPathIfFalse (con Prelude.MASTProp)
                       (bytestring)
                       (con Prelude.MASTPath)))
    
    
    (declare evalMASTPath
      (fun (con Prelude.MASTPath) Prelude.bool))
    (define evalMASTPath
      (lam m
        (case m
          (Prelude.MASTPathSuccess () Prelude.true)
          (Prelude.MASTPathFailure () Prelude.false)
          (Prelude.MASTPathIfTrue (test t f)
            (case [Prelude.evalMASTProp test]
              (Prelude.True () [Prelude.evalMASTPath t])
              (Prelude.False ()
                Prelude.false)))
          (Prelude.MASTPathIfFalse (test t f)
            (case [Prelude.evalMASTProp test]
              (Prelude.True ()
                Prelude.false)
              (Prelude.False () [Prelude.evalMASTPath f]))))))
    
    
    (declare hashMASTProp
      (fun (con Prelude.MASTProp) (bytestring)))
    (define hashMASTProp
      (lam m
        (case m
          (Prelude.MASTTrue () #00)
          (Prelude.MASTFalse () #01)
          (Prelude.MASTNot (x)
            [Prelude.sha2_256
              [Prelude.concatenate #02 [Prelude.hashMASTProp x]]])
          (Prelude.MASTAnd (x y)
            [Prelude.sha2_256
              [Prelude.concatenate #03
                [Prelude.concatenate
                  [Prelude.hashMASTProp x]
                  [Prelude.hashMASTProp y]]]])
          (Prelude.MASTOr (x y)
            [Prelude.sha2_256
              [Prelude.concatenate #04
                [Prelude.concatenate
                  [Prelude.hashMASTProp x]
                  [Prelude.hashMASTProp y]]]]))))
    
    
    (declare hashMASTTree
      (fun (con Prelude.MASTTree) (bytestring)))
    (define hashMASTTree
      (lam m
        (case m
          (Prelude.MASTSuccess () #00)
          (Prelude.MASTFailure () #01)
          (Prelude.MASTIf (test t f)
            [Prelude.sha2_256
              [Prelude.concatenate #02
                [Prelude.concatenate
                  [Prelude.hashMASTTree t]
                  [Prelude.hashMASTTree f]]]]))))
    
    
    (declare hashMASTPath
      (fun (con Prelude.MASTPath) (bytestring)))
    (define hashMASTPath
      (lam m
        (case m
          (Prelude.MASTPathSuccess () #00)
          (Prelude.MASTPathFailure () #01)
          (Prelude.MASTPathIfTrue (test t fhash)
            [Prelude.sha2_256
              [Prelude.concatenate #02
                [Prelude.concatenate
                  [Prelude.hashMASTPath t]
                  fhash]]])
          (Prelude.MASTPathIfFalse (test thash f)
            [Prelude.sha2_256
              [Prelude.concatenate #02
                [Prelude.concatenate
                  thash
                  [Prelude.hashMASTPath f]]]]))))
    
    
    (declare checkMAST
      (fun (bytestring)
           (fun (con Prelude.MASTPath)
                Prelude.bool)))
    (define checkMAST
      (lam hash (lam path
        (case [Prelude.evalMASTPath path]
          (Prelude.False ()
            Prelude.false)
          (Prelude.True ()
            [Prelude.equalsByteString
              hash
              [Prelude.hashMASTPath path]])))))
              

    -;

))